// üöÄ STACKSWORTH_MATRIX_MASTER USING OUR SATONAK API
// Built By BitcoinManor.com
// v2.0.46 - Device Identification & Personalization
// - Fixed: Display cycle infinite loop safety
// - Fixed: WiFi connection timeout extended to 30s  
// - Fixed: WDT crash prevention on initial fetch
// - Fixed: WiFi drops no longer trigger AP mode (1hr grace period)
// - Fixed: Display continues with cached data during WiFi reconnection
// - Improved: Heap memory checks now use named constant (MIN_HEAP_REQUIRED)
// - NEW: Device naming system - users can nickname their Matrix
// - NEW: Smart mDNS hostname (uses nickname or MAC-based fallback)
// - NEW: Identify endpoint - click button to see which device you're configuring
// - NEW: Device ID displayed on portal for multi-unit support
#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>
#include <WiFiManager.h> 
#include <HTTPClient.h>
#include <WiFiClient.h>
#include <ArduinoJson.h>
#include "esp_task_wdt.h"
#include "Font_Data.h" // Optional, if using custom fonts
#include "time.h"
#include <FS.h>
#include <SPIFFS.h>
#include <ESPAsyncWebServer.h>
#include <AsyncTCP.h>
#include <WiFi.h>
#include <esp_wifi.h>  // Needed for esp_read_mac
#include "esp_system.h"
#include <DNSServer.h>
DNSServer dnsServer;
#include <Preferences.h>
Preferences prefs;
#include <ESPmDNS.h>  // üåê For mDNS hostname resolution (Matrix.local)

// üß† Memory Management Constants
#define MIN_HEAP_REQUIRED 160000  // Minimum free heap (bytes) required before API calls

// retrieve and store the MAC
String getShortMAC() {
  uint8_t mac[6];
  esp_wifi_get_mac(WIFI_IF_STA, mac);  // Get STA interface MAC
  char shortID[7];
  sprintf(shortID, "%02X%02X%02X", mac[3], mac[4], mac[5]);  // last 3 bytes (6 hex chars)
  return String(shortID);
}

String macID;



bool wifiConnected = false;
bool buttonPressed = false;
volatile bool pendingReboot = false;
bool rebootPhaseShown = false;
unsigned long rebootAt = 0;
bool apMode = false;
bool apMsgShown = false;
bool initialFetchDone = false;  // Track if we've done first data fetch
bool hasEverConnected = false;  // Track if WiFi has ever successfully connected
unsigned long wifiDisconnectedAt = 0;  // Track when WiFi first disconnected
const unsigned long WIFI_FALLBACK_TIMEOUT = 60UL * 60UL * 1000UL;  // 1 hour before falling back to AP mode

String savedSSID;
String savedPassword;
String savedCity;
String savedCurrency;  // üåç New: User's preferred currency (USD, EUR, etc.)
String savedTheme;     // üé® New: User's preferred theme (scroll, fade)
String savedTopText;   // üìù New: User's custom top row message (max 10 chars)
String savedBottomText;// üìù New: User's custom bottom row message (max 10 chars)
String savedTempUnit;  // üå°Ô∏è New: User's preferred temperature unit (C or F)
String savedDeviceName;// üÜî New: User's device nickname (for multi-unit households)
uint8_t savedBrightness = 2; // üí° New: User's brightness preference (1-15)
bool displayEnabled[15] = {true, true, true, true, true, true, true, true, true, true, true, true, true, true, true}; // üìä Display options for each case (0-14)
int savedTimezone = -99;


// Fetch and Display Cycles
uint8_t fetchCycle = 0;   // üëà for rotating which API we fetch
uint8_t displayCycle = 0; // üëà for rotating which screen we show

// initializes the server so we can later attach our custom HTML page routes
AsyncWebServer server(80);

static WiFiClient httpClient;

// üêï WDT Helper: Feed watchdog and yield to WiFi/RTOS
static inline void feedWDT() {
  esp_task_wdt_reset();
  delay(1);  // yield to WiFi/RTOS tasks
}

// üåç API Endpoints
const char* BTC_API = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true";;
const char *BLOCK_API = "https://blockchain.info/q/getblockcount";
const char *FEES_API = "https://mempool.space/api/v1/fees/recommended";
const char *MEMPOOL_BLOCKS_API = "https://mempool.space/api/blocks";
const char *BLOCKSTREAM_TX_API_BASE = "https://blockstream.info/api/block/";

// ===== SatoNak API (authoritative) =====
#define USE_SATONAK_PRICE 1    // 1 = use SatoNak for price, 0 = keep old source

static const char* SATONAK_BASE   = "https://satonak.bitcoinmanor.com";
static const char* SATONAK_PRICE  = "/api/price";   // supports ?fiat=EUR etc.
static const char* SATONAK_HEIGHT = "/api/height";  // (for later)
static const char* SATONAK_MINER  = "/api/miner";   // (for later)

// Staggered fetch intervals (ms)
const unsigned long INTERVAL_BLOCK_HEIGHT = 5UL * 60UL * 1000UL; // 5 min
const unsigned long INTERVAL_MINER       = 6UL * 60UL * 1000UL; // 6 min
const unsigned long INTERVAL_PRICE       = 7UL * 60UL * 1000UL; // 7 min
const unsigned long INTERVAL_CHANGE24H   = 8UL * 60UL * 1000UL; // 8 min
const unsigned long INTERVAL_FEE         = 9UL * 60UL * 1000UL; // 9 min
const unsigned long INTERVAL_HASHRATE    = 10UL * 60UL * 1000UL; // 10 min
const unsigned long INTERVAL_CIRC_SUPPLY = 11UL * 60UL * 1000UL; // 11 min
const unsigned long INTERVAL_ATH         = 12UL * 60UL * 1000UL; // 12 min
const unsigned long INTERVAL_DAYS_ATH    = 13UL * 60UL * 1000UL; // 13 min

// Last fetch timestamps
unsigned long lastBlockHeightFetch   = 0;
unsigned long lastMinerFetch        = 0;
unsigned long lastPriceFetch        = 0;
unsigned long lastFeeFetch          = 0;
unsigned long lastHashrateFetch     = 0;
unsigned long lastCircSupplyFetch   = 0;
unsigned long lastAthFetch          = 0;
unsigned long lastDaysAthFetch      = 0;
unsigned long lastChange24hFetch    = 0;

// default fiat (can be "USD", "EUR", etc.) - now loaded from preferences
static String getCurrentFiatCode() {
  return savedCurrency.length() > 0 ? savedCurrency : "USD";
}

// Get currency symbol for display
static String getCurrencySymbol() {
  String fiat = getCurrentFiatCode();
  if (fiat == "USD") return "$";
  if (fiat == "CAD") return "$";       // Clean $ since top row shows "CAD PRICE"
  if (fiat == "EUR") return "";        // Clean number since top row shows "EUR PRICE"  
  if (fiat == "GBP") return "";        // Clean number since top row shows "GBP PRICE"
  if (fiat == "JPY") return "";        // Clean number since top row shows "JPY PRICE" (avoid encoding issues)
  if (fiat == "AUD") return "$";       // Clean $ since top row shows "AUD PRICE"
  if (fiat == "CHF") return "";        // Clean number since top row shows "CHF PRICE"
  if (fiat == "CNY") return "";        // Clean number since top row shows "CNY PRICE"
  if (fiat == "SEK") return "";        // Clean number since top row shows "SEK PRICE"
  if (fiat == "NOK") return "";        // Clean number since top row shows "NOK PRICE"
  return ""; // fallback to no symbol
}

static inline String satonakUrl(const char* path, const char* fiat = nullptr) {
  String u = String(SATONAK_BASE) + String(path);
  if (fiat && fiat[0] != '\0') {
    u += "?fiat="; u += fiat;
  }
  return u;
}

// üé® Get animation effects based on user's theme preference
static void getThemeEffects(textEffect_t &effectIn, textEffect_t &effectOut) {
  if (savedTheme == "fade") {
    Serial.println("üé® Using WIPE theme (power-efficient alternative to fade)");
    effectIn = PA_WIPE_CURSOR;
    effectOut = PA_WIPE_CURSOR;
  } else {
    // Default to scroll theme (safe fallback)
    Serial.println("üé® Using SCROLL theme");
    effectIn = PA_SCROLL_LEFT;
    effectOut = PA_SCROLL_LEFT;
  }
}


// ---- Smash Buy phrases split into TOP / BOTTOM lines ----
const char* PHRASES[][2] = {
  { "SMASH",           "BUY!" },
  { "DON'T TRUST",     "VERIFY!" },
  { "STACK",           "SATS" },
  { "RUN A",           "NODE" },
  { "NOT YOUR",        "KEYS" },
  { "FIX THE",         "MONEY" },
  { "STAY",            "HUMBLE" },
  { "OPT",             "OUT" },
  { "LOW TIME",       "PREFERENCE" },  // fun variation
  { "INFINITE",        "GAME" },
  { "HARDER",          "MONEY" },
  { "BITCOIN",         "> FIAT" },
  { "LET'S",            "GO" }
};
#define NUM_PHRASES (sizeof(PHRASES) / sizeof(PHRASES[0]))

String mapWeatherCode(int code)
{
  if (code == 0)
    return "Sunny";
  else if (code == 1)
    return "Mostly Sunny";
  else if (code == 2)
    return "Partly Cloudy";
  else if (code == 3)
    return "Cloudy";
  else if (code >= 45 && code <= 48)
    return "Foggy";
  else if (code >= 51 && code <= 57)
    return "Drizzle";
  else if (code >= 61 && code <= 67)
    return "Rain";
  else if (code >= 71 && code <= 77)
    return "Snowy";
  else if (code >= 80 && code <= 82)
    return "Showers";
  else if (code >= 85 && code <= 86)
    return "Snow Showers";
  else if (code >= 95 && code <= 99)
    return "Thunderstorm";
  else
    return "Unknown";
}

// Time Config
const char *ntpServer = "pool.ntp.org";
// üåç Timezone strings that auto-handle DST (no more manual updates needed!)
const char* TIMEZONE_STRINGS[] = {
  "UTC0",                                    // UTC +0
  "GMT0BST,M3.5.0/1,M10.5.0",              // London +0/+1
  "CET-1CEST,M3.5.0,M10.5.0/3",            // Paris/Berlin +1/+2
  "EET-2EEST,M3.5.0/3,M10.5.0/4",          // Helsinki +2/+3
  "MSK-3",                                  // Moscow +3 (no DST)
  "JST-9",                                  // Tokyo +9 (no DST)
  "AEST-10AEDT,M10.1.0,M4.1.0/3",          // Sydney +10/+11
  "NZST-12NZDT,M9.5.0,M4.1.0/3",           // Auckland +12/+13
  "HST10",                                  // Hawaii -10 (no DST)
  "AKST9AKDT,M3.2.0,M11.1.0",              // Alaska -9/-8
  "PST8PDT,M3.2.0,M11.1.0",                // Pacific -8/-7
  "MST7MDT,M3.2.0,M11.1.0",                // Mountain -7/-6
  "CST6CDT,M3.2.0,M11.1.0",                // Central -6/-5
  "EST5EDT,M3.2.0,M11.1.0"                 // Eastern -5/-4
};

const char* TIMEZONE_NAMES[] = {
  "UTC (+0)", "London (+0/+1)", "Paris (+1/+2)", "Helsinki (+2/+3)",
  "Moscow (+3)", "Tokyo (+9)", "Sydney (+10/+11)", "Auckland (+12/+13)",
  "Hawaii (-10)", "Alaska (-9/-8)", "Pacific (-8/-7)", "Mountain (-7/-6)",
  "Central (-6/-5)", "Eastern (-5/-4)"
};

#define NUM_TIMEZONES (sizeof(TIMEZONE_STRINGS) / sizeof(TIMEZONE_STRINGS[0]))

// Global Data Variables
int btcPrice = 0, blockHeight = 0, feeRate = 0, satsPerDollar = 0;
char btcText[16], blockText[16], feeText[16], satsText[16], satsText2[16];
char timeText[16], dateText[16], dayText[16];
char hashrateText[16];  // New global for hashrate display
char circSupplyText[16];  // New global for circulating supply top line  
char circPercentText[16]; // New global for circulating supply bottom line
float latitude = 0.0;
float longitude = 0.0;
String weatherCondition = "Unknown";
int temperature = 0;
float btcChange24h = 0.0;
char changeText[16];
String minerName = "Unknown";
String hashrate = "Unknown";  // New global for hashrate data
String circSupply = "Unknown"; // New global for circulating supply data
String athPrice = "Unknown";   // New global for ATH price data
String daysSinceAth = "Unknown"; // New global for days since ATH data
char athText[16];              // New global for ATH price display
char daysAthText[16];          // New global for days since ATH display

String formatWithCommas(int number)
{
  String numStr = String(number);
  String result = "";
  int len = numStr.length();
  for (int i = 0; i < len; i++)
  {
    if (i > 0 && (len - i) % 3 == 0)
      result += ",";
    result += numStr[i];
  }
  return result;
}

// Save successful values to cache for fallback use
void saveDisplayCache() {
  prefs.begin("cache", false);  // write mode
  prefs.putString("btcText", String(btcText));
  prefs.putString("blockText", String(blockText));
  prefs.putString("feeText", String(feeText));
  prefs.putString("satsText", String(satsText));
  prefs.putString("changeText", String(changeText));
  prefs.putString("athText", String(athText));
  prefs.putString("daysAthText", String(daysAthText));
  prefs.putString("hashrateText", String(hashrateText));
  prefs.putString("circSupplyText", String(circSupplyText));
  prefs.putString("minerName", minerName);
  prefs.end();
  Serial.println("üíæ Display cache saved");
}

// LED Matrix Config
#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_ZONES 2
#define ZONE_SIZE 8
#define MAX_DEVICES (MAX_ZONES * ZONE_SIZE)
#define SCROLL_SPEED 20
#define FETCH_INTERVAL 120000

#define ZONE_LOWER 0
#define ZONE_UPPER 1

#define CLK_PIN 18
#define DATA_PIN 23
#define CS_PIN 5
#define BUTTON_PIN 25   //Pin for Smash Buy Button

MD_Parola P = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);
// Brightness: 0 = dimmest, 15 = brightest
uint8_t BRIGHTNESS = 2;

// Function to adjust brightness
void setBrightness(uint8_t level) {
  if (level > 15) level = 15;  // Clamp to max
  BRIGHTNESS = level;
  
  // Set intensity for each zone individually (required for multi-zone displays)
  P.setIntensity(ZONE_UPPER, BRIGHTNESS);
  P.setIntensity(ZONE_LOWER, BRIGHTNESS);
  
  // Save brightness setting to preferences
  prefs.begin("stacksworth", false);
  prefs.putUChar("brightness", BRIGHTNESS);
  prefs.end();
  
  Serial.printf("üí° Brightness set to: %d/15 for all zones\n", BRIGHTNESS);
}

// Function to cycle brightness (for potential button control)
void cycleBrightness() {
  BRIGHTNESS = (BRIGHTNESS + 3) % 16;  // Step by 3 for noticeable changes
  if (BRIGHTNESS == 0) BRIGHTNESS = 3; // Don't go completely dark
  setBrightness(BRIGHTNESS);
}
unsigned long lastFetchTime = 0;
uint8_t cycle = 0;             // üî• Needed for animation control
unsigned long lastApiCall = 0; // üî• Needed for fetch timing
unsigned long lastMemoryCheck = 0;
unsigned long lastWeatherUpdate = 0;
unsigned long lastNTPUpdate = 0;

const unsigned long WEATHER_UPDATE_INTERVAL = 30UL * 60UL * 1000UL; // 30 minutes
const unsigned long NTP_UPDATE_INTERVAL = 10UL * 60UL * 1000UL;     // 10 minutes
const unsigned long MEMORY_CHECK_INTERVAL = 5UL * 60UL * 1000UL;    // 5 minutes

const uint32_t BTC_INTERVAL     = 300000;   // 5 min
const uint32_t FEE_INTERVAL     = 300000;   // 5 min
const uint32_t BLOCK_INTERVAL   = 300000;   // 5 min
const uint32_t WEATHER_INTERVAL = 1800000;  // 30 min

const uint32_t FEE_OFFSET     =  90000;   // +1.5 min after BTC
const uint32_t BLOCK_OFFSET   = 180000;   // +3   min after BTC
const uint32_t WEATHER_OFFSET =  60000;   // +1   min after BTC

static uint32_t lastBTC = 0, lastFee = 0, lastBlock = 0, lastWeather = 0;
static uint32_t bootMs = 0;


// Pre Connection Message for home users
void showPreConnectionMessage()
{
  static uint8_t step = 0;
  static unsigned long lastUpdate = 0;

  if (millis() - lastUpdate < 2500)
    return; // Wait for 2.5 seconds between steps
  lastUpdate = millis();

  switch (step)
  {
  case 0:
    P.displayZoneText(ZONE_UPPER, "ENTER THE", PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "MATRIX", PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
    break;
  case 1:
    P.displayZoneText(ZONE_UPPER, "Connect Your", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "Device Inside", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 2:
    P.displayZoneText(ZONE_UPPER, "WiFi Settings", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "Labelled", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 3:
    P.displayZoneText(ZONE_UPPER, "SW-MATRIX", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "******", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 4:
    P.displayZoneText(ZONE_UPPER, "OR TYPE", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "192.168.4.1", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 5:
    P.displayZoneText(ZONE_UPPER, "SETUP WiFi", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "and hit SAVE", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  default:
    step = 0; // Reset the sequence
    return;
  }

  step++;
}

 //Load Saved WiFi + City + Timezone on Boot
void loadSavedSettingsAndConnect() {
  prefs.begin("stacksworth", true);  

  savedSSID = prefs.getString("ssid", "");
  savedPassword = prefs.getString("password", "");
  savedCity = prefs.getString("city", "");
  savedCurrency = prefs.getString("currency", "USD");  // üåç Default to USD
  savedTheme = prefs.getString("theme", "scroll");     // üé® Default to scroll
  savedTopText = prefs.getString("toptext", "");       // üìù Custom top row message
  savedBottomText = prefs.getString("bottomtext", ""); // üìù Custom bottom row message
  savedTempUnit = prefs.getString("tempunit", "C");    // üå°Ô∏è Default to Celsius
  savedDeviceName = prefs.getString("devicename", ""); // üÜî User's device nickname
  savedBrightness = prefs.getUChar("brightness", 2);  // üí° Load brightness preference (default 2)
  savedTimezone = prefs.getInt("timezone", -99);
  BRIGHTNESS = savedBrightness;                        // üí° Apply saved brightness
  
  // üìä Load display options for each case (default all enabled)
  for (int i = 0; i < 15; i++) {
    String key = "show" + String(i);
    displayEnabled[i] = prefs.getUChar(key.c_str(), 1) == 1;  // Default to 1 (enabled)
  }

  prefs.end();

  if (savedSSID != "" && savedPassword != "") {
    Serial.println("‚úÖ Found Saved WiFi Credentials:");
    Serial.println("SSID: " + savedSSID);
    Serial.println("Password: (hidden)");
    Serial.println("City: " + savedCity);
    Serial.println("Currency: " + savedCurrency);        // üåç New
    Serial.println("Theme: " + savedTheme);              // üé® New
    Serial.println("Custom Top: " + savedTopText);       // üìù New
    Serial.println("Custom Bottom: " + savedBottomText); // üìù New
    Serial.println("Temperature Unit: " + savedTempUnit); // üå°Ô∏è New
    Serial.println("Device Name: " + savedDeviceName);   // üÜî New
    Serial.printf("Brightness: %d/15\n", BRIGHTNESS);    // üí° New
    Serial.print("Timezone offset (hours): ");
    Serial.println(savedTimezone);

    WiFi.mode(WIFI_STA);
    WiFi.begin(savedSSID.c_str(), savedPassword.c_str());

    Serial.print("üîå Connecting to WiFi...");
    unsigned long startAttemptTime = millis();

    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 30000) {
      Serial.print(".");
      esp_task_wdt_reset(); // Feed watchdog  
      delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ Connected to WiFi successfully!");
      Serial.print("üåç IP Address: ");
      Serial.println(WiFi.localIP());
      wifiConnected = true; // üëâ set this!!
      hasEverConnected = true; // üëâ Remember we've connected successfully
      wifiDisconnectedAt = 0; // Reset disconnection timer
      WiFi.setAutoReconnect(true); // Enable auto-reconnect for normal operation
      
      // üåç Configure timezone using proper timezone strings (auto-handles DST!)
      if (savedTimezone != -99 && savedTimezone >= 0 && savedTimezone < NUM_TIMEZONES) {
        const char* tzString = TIMEZONE_STRINGS[savedTimezone];
        configTzTime(tzString, ntpServer);
        Serial.printf("üïí Timezone configured: %s (%s)\n", TIMEZONE_NAMES[savedTimezone], tzString);
      } else {
        // Default to Mountain Time if no valid timezone saved
        configTzTime(TIMEZONE_STRINGS[11], ntpServer); // Mountain Time
        Serial.println("üïí Using default Mountain Time timezone");
      }
    } else {
      Serial.println("\n‚ùå Failed to connect to WiFi, falling back to Access Point...");
      WiFi.persistent(false); // Don't save WiFi config to flash
      startAccessPoint();
    }
  } else {
    Serial.println("‚ö†Ô∏è No saved WiFi credentials found, starting Access Point...");
    WiFi.persistent(false); // Don't save WiFi config to flash
    startAccessPoint();
  }
}

  
    // Access Point Code
    void startAccessPoint()
    {
      Serial.println("üöÄ Starting Access Point...");
      WiFi.mode(WIFI_OFF); // Completely turn off WiFi first
      delay(100);
      WiFi.disconnect(true); // Disconnect and disable auto-reconnect
      WiFi.setAutoReconnect(false); // Explicitly disable auto-reconnect
      delay(100); // Give it a moment to fully disconnect
      WiFi.mode(WIFI_AP); // Now set to AP-only mode
      macID = getShortMAC();  // Store globally
      String ssid = "SW-MATRIX-" + getShortMAC();
      WiFi.softAP(ssid.c_str());

      apMode = true;
      apMsgShown = false;


      IPAddress myIP = WiFi.softAPIP();
      Serial.print("üåç AP IP address: ");
      Serial.println(myIP);
      Serial.print("üì∂ AP SSID: ");
      Serial.println(ssid); // Helpful for debug

      // DNS Captive portal
      dnsServer.start(53, "*", myIP);
      Serial.println("üöÄ DNS Server started for captive portal.");
    }

    // FETCH FUNCTIONS
    void fetchBitcoinData() {
  // Try SatoNak first, then fallback to CoinGecko
  if (fetchPriceFromSatoNak()) {
    Serial.println("‚úÖ Bitcoin price fetched from SatoNak");
    return;
  }
  
  Serial.println("‚ö†Ô∏è SatoNak failed, trying CoinGecko fallback");
  
  // ‚úÖ GUARD: Don't attempt CoinGecko unless WiFi is actually connected
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping CoinGecko fallback");
    return;
  }

  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
    return;
  }
  Serial.println("üîÑ Fetching BTC Price from CoinGecko...");
  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500);
  
  feedWDT();
  http.begin(BTC_API);
  
  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö†Ô∏è WiFi dropped before GET - aborting CoinGecko");
    http.end();
    return;
  }
  
  int httpCode = http.GET();
  feedWDT();
  
  if (httpCode == 200) {
    DynamicJsonDocument doc(512);
    deserializeJson(doc, http.getString());
    btcPrice = doc["bitcoin"]["usd"];
    btcChange24h = doc["bitcoin"]["usd_24h_change"];
    satsPerDollar = 100000000 / btcPrice;

    String symbol = getCurrencySymbol();
    String currentFiat = getCurrentFiatCode();
    
    // Note: CoinGecko fallback only provides USD, so if user wants other currency,
    // they'll need to wait for SatoNak to come back online for FX conversion
    if (currentFiat == "USD") {
      sprintf(btcText, "$%s", formatWithCommas(btcPrice).c_str());
      sprintf(satsText, "$1=%d Sats", satsPerDollar);
    } else {
      sprintf(btcText, "$%s*", formatWithCommas(btcPrice).c_str()); // * indicates USD fallback
      sprintf(satsText, "$1=%d Sats*", satsPerDollar); // * shows it's USD fallback
    }
    sprintf(satsText2, "%d Sats", satsPerDollar);
    snprintf(changeText, sizeof(changeText), "%+.2f%%", btcChange24h);

    Serial.printf("‚úÖ Updated BTC Price: $%d | Sats per $: %d\n", btcPrice, satsPerDollar);
    Serial.printf("‚úÖ BTC Price: %s (%s)\n", btcText, satsText);
  } else {
    Serial.printf("‚ùå CoinGecko GET failed (%d)\n", httpCode);
  }
  http.end();
  Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
}

// Returns true on success, false on any failure (so callers can fallback)
bool fetchPriceFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak price fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak price fetch");
    return false;
  }

  String currentFiat = getCurrentFiatCode();
  String full = satonakUrl(SATONAK_PRICE, currentFiat.c_str()); // e.g. /api/price?fiat=EUR
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);      // Reduced to 2s to stay well under 12s WDT
  http.setConnectTimeout(1500);
  http.useHTTP10(true);
  http.setReuse(false);

  feedWDT();
  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö†Ô∏è WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak price GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Check if payload is plain text (just a number) vs JSON
  payload.trim();
  if (payload.length() > 0 && payload.length() < 16 && isdigit(payload.charAt(0))) {
    // Plain text response - just a price number like "103605.00"
    double px = payload.toFloat();
    if (px > 0) {
      btcPrice = (int)round(px);
      satsPerDollar = (int)(100000000.0 / px);
      
      String symbol = getCurrencySymbol();
      snprintf(btcText, sizeof(btcText), "%s%s", symbol.c_str(), formatWithCommas(btcPrice).c_str());
      
      // üåç Show sats per user's currency, not always USD!
      sprintf(satsText, "%s1=%d Sats", symbol.c_str(), satsPerDollar);
      sprintf(satsText2, "%d Sats", satsPerDollar);
      
      Serial.printf("‚úÖ SatoNak Price (plain): %s | Sats/$: %d | Free heap: %d\n",
                    btcText, satsPerDollar, ESP.getFreeHeap());
      return true;
    }
  }

  // Try parsing as JSON
  DynamicJsonDocument doc(1536);
  DeserializationError e = deserializeJson(doc, payload);
  if (e) {
    Serial.printf("‚ùå SatoNak JSON parse error: %s\n", e.c_str());
    Serial.println("‚Ü™Ô∏é Payload (trim): " + payload.substring(0, 220));
    return false;
  }

  // Respect your current fiat setting (e.g., "USD"/"EUR"/"CAD")
  String key = currentFiat; key.toLowerCase();

  double px = 0.0;
  if (doc.containsKey("price") && doc["price"].is<JsonObject>()) {
    if (doc["price"][key].is<double>()) px = (double)doc["price"][key];
    else if (doc["price"][key].is<long>()) px = (double)((long)doc["price"][key]);
  }
  if (px <= 0.0) {
    if (doc[key].is<double>()) px = (double)doc[key];
    else if (doc[key].is<long>()) px = (double)((long)doc[key]);
  }
  if (px <= 0.0) {
    Serial.println("‚ùå SatoNak: no valid price in payload");
    Serial.println("‚Ü™Ô∏é Payload (trim): " + payload.substring(0, 220));
    return false;
  }

  double change = 0.0;
  if (doc["change_24h"].is<double>()) change = (double)doc["change_24h"];

  long sps = 0;
  if (doc["sats_per_usd"].is<long>()) sps = (long)doc["sats_per_usd"];
  if (sps == 0 && key == "usd") sps = (long)(100000000.0 / px);

  // Update your existing globals/buffers (exact names as in your sketch)
  btcPrice      = (int)round(px);
  btcChange24h  = (float)change;
  satsPerDollar = (int)sps;

  String symbol = getCurrencySymbol();
  
  if (currentFiat == "USD") {
    snprintf(btcText, sizeof(btcText), "$%s", formatWithCommas(btcPrice).c_str());
  } else {
    snprintf(btcText, sizeof(btcText), "%s%s", symbol.c_str(), formatWithCommas(btcPrice).c_str());
  }
  
  // üåç Show sats per user's selected currency!
  sprintf(satsText,   "%s1=%d Sats", symbol.c_str(), satsPerDollar);
  sprintf(satsText2,  "%d Sats", satsPerDollar);
  snprintf(changeText, sizeof(changeText), "%+.2f%%", btcChange24h);

  Serial.printf("‚úÖ SatoNak Price: %s | 24h: %+.2f%% | Sats/$: %d | Free heap: %d\n",
                btcText, btcChange24h, satsPerDollar, ESP.getFreeHeap());
  return true;
}

// Fetch miner info from SatoNak API
bool fetchMinerFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak miner fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak miner fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + String(SATONAK_MINER);
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  feedWDT();
  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak miner)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak miner GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // For simple text response, just use the payload directly
  payload.trim();
  if (payload.length() > 0 && payload.length() < 32) {
    minerName = payload;
    Serial.printf("‚úÖ SatoNak Miner: %s | Free heap: %d\n", minerName.c_str(), ESP.getFreeHeap());
    return true;
  } else {
    Serial.println("‚ùå SatoNak miner: invalid response");
    Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
    return false;
  }
}

// Fetch block height from SatoNak API
bool fetchHeightFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak height fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak height fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + String(SATONAK_HEIGHT);
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500);
  http.useHTTP10(true);
  http.setReuse(false);

  feedWDT();
  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak height)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak height GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // For simple text response, parse as integer
  payload.trim();
  int newHeight = payload.toInt();
  if (newHeight > 0 && newHeight > blockHeight - 100) { // sanity check
    blockHeight = newHeight;
    sprintf(blockText, "%d", blockHeight);
    Serial.printf("‚úÖ SatoNak Height: %d | Free heap: %d\n", blockHeight, ESP.getFreeHeap());
    return true;
  } else {
    Serial.println("‚ùå SatoNak height: invalid response");
    Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 50));
    return false;
  }
}


    void fetchBlockHeight()
    {
      // Try SatoNak only - no fallback to prevent WDT crashes
      // If it fails, continue with cached data
      if (fetchHeightFromSatoNak()) {
        Serial.println("‚úÖ Block height fetched from SatoNak");
      } else {
        Serial.println("‚ö†Ô∏è SatoNak height fetch failed - continuing with cached data");
      }
    }

// Fetch fee rate from SatoNak API
bool fetchFeeFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak fee fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak fee fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/fee";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak fee)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak fee GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Check if payload is plain text (just a number) vs JSON
  payload.trim();
  if (payload.length() > 0 && payload.length() < 8 && isdigit(payload.charAt(0))) {
    // Plain text response - just a fee number like "15"
    int newFee = payload.toInt();
    if (newFee > 0 && newFee < 1000) { // sanity check
      feeRate = newFee;
      snprintf(feeText, sizeof(feeText), "%d sat/vB", feeRate);
      Serial.printf("‚úÖ SatoNak Fee (plain): %d sat/vB | Free heap: %d\n", feeRate, ESP.getFreeHeap());
      return true;
    }
  }

  // Try parsing as JSON
  DynamicJsonDocument doc(512);
  DeserializationError e = deserializeJson(doc, payload);
  if (e) {
    Serial.printf("‚ùå SatoNak fee JSON parse error: %s\n", e.c_str());
    Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
    return false;
  }

  // Parse JSON response
  int newFee = 0;
  if (doc.containsKey("value")) {
    newFee = doc["value"];
  }
  
  if (newFee > 0 && newFee < 1000) { // sanity check
    feeRate = newFee;
    snprintf(feeText, sizeof(feeText), "%d sat/vB", feeRate);
    Serial.printf("‚úÖ SatoNak Fee: %d sat/vB | Free heap: %d\n", feeRate, ESP.getFreeHeap());
    return true;
  }

  Serial.println("‚ùå SatoNak fee: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}

void fetchFeeRate() {
  // Try SatoNak first, then fallback to mempool.space
  if (fetchFeeFromSatoNak()) {
    Serial.println("‚úÖ Fee rate fetched from SatoNak");
    return;
  }
  
  Serial.println("‚ö†Ô∏è SatoNak failed, trying mempool.space fallback");
  
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("üõë Low heap before Fee fetch; skipping");
    return;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping Fee fetch");
    return;
  }

  Serial.println("üîÑ Fetching Fee Rate from mempool.space‚Ä¶");
  HTTPClient http;
  // short, explicit timeouts so we never stall long enough to trip WDT
  http.setTimeout(2000);         // Reduced from 3000ms
  http.setConnectTimeout(1500);  // Reduced from 2000ms 
  http.useHTTP10(true);          // simpler, avoids chunking issues
  http.setReuse(false);          // no keep-alive reuse

  // FEES_API should be your existing endpoint string, unchanged
  if (!http.begin(httpClient, FEES_API)) {
    Serial.println("‚ùå http.begin failed; keeping last fee value");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return;
  }
  int rc = http.GET();
  feedWDT();
  if (rc == 200) {
    String payload = http.getString();
    DynamicJsonDocument doc(512);
    DeserializationError e = deserializeJson(doc, payload);
    if (e) {
      Serial.printf("‚ùå Fee JSON parse error: %s; keeping last value\n", e.c_str());
    } else {
      // keep previous value if field missing
      int newFee = doc["fastestFee"] | feeRate;
      feeRate = newFee;
      // feeText should be your existing global char buffer
      snprintf(feeText, sizeof(feeText), "%d sat/vB", feeRate);
      Serial.printf("‚úÖ Updated Fee Rate: %d sat/vB\n", feeRate);
    }
  } else {
    Serial.printf("‚ùå Fee GET failed (%d); keeping last value\n", rc);
  }
  http.end();
}

// Fetch hashrate from SatoNak API
bool fetchHashrateFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak hashrate fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak hashrate fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/hashrate";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak hashrate)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak hashrate GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Parse and format the hashrate number
  payload.trim();
  if (payload.length() > 0 && payload.length() < 32 && payload != "na") {
    strncpy(hashrateText, payload.c_str(), sizeof(hashrateText));
    hashrateText[sizeof(hashrateText)-1] = '\0';
    hashrate = payload; // keep if you also want the raw string elsewhere
    Serial.printf("‚úÖ SatoNak Hashrate -> Display: %s | Free heap: %d\n",
                  hashrateText, ESP.getFreeHeap());
    return true;
  }
  
  Serial.println("‚ùå SatoNak hashrate: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}

// Fetch circulating supply from SatoNak API
bool fetchCircSupplyFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak circulating supply fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak circulating supply fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/circsupply";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak circulating supply)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak circulating supply GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // For simple text response, parse as number
  payload.trim();
  Serial.printf("üîç Raw circulating supply payload: '%s'\n", payload.c_str());
  
  if (payload.length() > 0 && payload.length() < 16 && payload != "na") {
    // Remove commas temporarily for parsing
    String cleanPayload = payload;
    cleanPayload.replace(",", "");
    Serial.printf("üîç After removing commas for parsing: '%s'\n", cleanPayload.c_str());
    
    long supply = cleanPayload.toInt();
    Serial.printf("üîç Parsed supply as: %ld\n", supply);
    
    if (supply > 0 && supply <= 21000000) { // sanity check - supply should be reasonable
      circSupply = payload; // Store original with commas for display
      
      // Format for display: actual numbers with commas
      // Top: current supply with commas (e.g., "19,942,004")
      strncpy(circSupplyText, payload.c_str(), sizeof(circSupplyText));
      circSupplyText[sizeof(circSupplyText) - 1] = '\0';
      
      // Bottom: max supply (always "21,000,000")
      strncpy(circPercentText, "/21 Million", sizeof(circPercentText));
      circPercentText[sizeof(circPercentText) - 1] = '\0';
      
      Serial.printf("‚úÖ SatoNak Circulating Supply: %s (%s, %s) | Free heap: %d\n", 
                    circSupply.c_str(), circSupplyText, circPercentText, ESP.getFreeHeap());
      return true;
    } else {
      Serial.printf("‚ùå SatoNak circulating supply: supply value %ld out of range (expected 0-21000000)\n", supply);
    }
  }
  
  Serial.println("‚ùå SatoNak circulating supply: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}

// Fetch ATH price from SatoNak API
bool fetchAthFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak ATH fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak ATH fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/ath";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak ATH)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak ATH GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Parse ATH price - API returns plain text like "73750.07"
  payload.trim();
  if (payload.length() > 0 && payload.length() < 16 && payload != "na") {
    float athPriceNum = payload.toFloat();
    if (athPriceNum > 0) {
      athPrice = payload; // Store raw value
      
  // Format for display - add $ and format nicely with commas (e.g. $126,080)
  // Use existing helper to insert thousand separators
  snprintf(athText, sizeof(athText), "$%s", formatWithCommas((int)round(athPriceNum)).c_str());
      
      Serial.printf("‚úÖ SatoNak ATH: %s -> Display: %s | Free heap: %d\n", 
                    athPrice.c_str(), athText, ESP.getFreeHeap());
      return true;
    }
  }
  
  Serial.println("‚ùå SatoNak ATH: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}

// Fetch 24H change from SatoNak API
bool fetchChange24hFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak 24H change fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak 24H change fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/change24h";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak 24H change)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak 24H change GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Parse 24H change - API returns plain text like "+1.29%" or "-2.45%"
  payload.trim();
  if (payload.length() > 0 && payload.length() < 16 && payload != "na") {
    // Extract the numeric value for internal storage
    String numStr = payload;
    numStr.replace("+", "");
    numStr.replace("%", "");
    btcChange24h = numStr.toFloat();
    
    // Store the formatted display text
    strncpy(changeText, payload.c_str(), sizeof(changeText));
    changeText[sizeof(changeText) - 1] = '\0';
    
    Serial.printf("‚úÖ SatoNak 24H Change: %s (%.2f%%) | Free heap: %d\n", 
                  changeText, btcChange24h, ESP.getFreeHeap());
    return true;
  }
  
  Serial.println("‚ùå SatoNak 24H change: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}

// Fetch days since ATH from SatoNak API
bool fetchDaysSinceAthFromSatoNak() {
  if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED) {
    Serial.println("‚ùå Low heap; skipping SatoNak days since ATH fetch");
    return false;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping SatoNak days since ATH fetch");
    return false;
  }

  String full = String(SATONAK_BASE) + "/api/days_since_ath";
  Serial.print("üåê GET "); Serial.println(full);

  HTTPClient http;
  http.setTimeout(2000);
  http.setConnectTimeout(1500); 
  http.useHTTP10(true);
  http.setReuse(false);

  if (!http.begin(full)) {
    Serial.println("‚ùå http.begin failed (SatoNak days since ATH)");
    http.end(); // ‚ö†Ô∏è CRITICAL: Always call end() even on begin() failure to free resources
    return false;
  }

  feedWDT();
  // Double-check WiFi right before blocking GET call
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println(" WiFi dropped before GET - aborting");
    http.end();
    return false;
  }
  int rc = http.GET();
  feedWDT();
  if (rc != 200) {
    Serial.printf("‚ùå SatoNak days since ATH GET failed (%d)\n", rc);
    http.end();
    return false;
  }

  String payload = http.getString();
  feedWDT();
  http.end();

  // Parse days since ATH - API returns plain text like "45"
  payload.trim();
  if (payload.length() > 0 && payload.length() < 8 && payload != "na") {
    int days = payload.toInt();
    if (days >= 0) {
      daysSinceAth = payload; // Store raw value
      
      // Format for display - "## Days" format for top row
      snprintf(daysAthText, sizeof(daysAthText), "%d Days", days);
      
      Serial.printf("‚úÖ SatoNak Days Since ATH: %s -> Display: %s | Free heap: %d\n", 
                    daysSinceAth.c_str(), daysAthText, ESP.getFreeHeap());
      return true;
    }
  }
  
  Serial.println("‚ùå SatoNak days since ATH: invalid response");
  Serial.println("‚Ü™Ô∏é Payload: " + payload.substring(0, 100));
  return false;
}


    void fetchTime()
    {
      if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      struct tm timeinfo;
      if (!getLocalTime(&timeinfo))
      {
        Serial.println("‚ùå Failed to fetch local time! Keeping previous timeText...");
        return; // Don't overwrite global time values if fetch fails
      }

      Serial.println("‚è∞ Local time fetched successfully!");

      // Format to HH:MMam/pm, then strip leading zero
      char buf[16];
      strftime(buf, sizeof(buf), "%I:%M%p", &timeinfo);
      if (buf[0] == '0')
        memmove(buf, buf + 1, strlen(buf + 1) + 1); // Strip leading 0

      // ‚úÖ Update globals only if time fetch succeeded
      strncpy(timeText, buf, sizeof(timeText));
      timeText[sizeof(timeText) - 1] = '\0';

      strftime(dateText, sizeof(dateText), "%b %d", &timeinfo);
      strftime(dayText, sizeof(dayText), "%A", &timeinfo);

      Serial.printf("‚úÖ Updated Time: %s | Date: %s | Day: %s\n", timeText, dateText, dayText);
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    void fetchLatLonFromCity()
    {
      if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      if (savedCity == "")
      {
        Serial.println("‚ö†Ô∏è No saved city found, skipping geolocation fetch.");
        return;
      }

      HTTPClient http;
      String url = "https://nominatim.openstreetmap.org/search?city=" + savedCity + "&format=json";
      http.setTimeout(2000);      // Prevent hanging
      http.setConnectTimeout(1500); // Connection timeout
      http.useHTTP10(true);       // Use HTTP/1.0 for better stability
      http.setReuse(false);       // Don't reuse connection
      http.begin(url);
      
      esp_task_wdt_reset(); // Feed watchdog before HTTP operation
      int httpResponseCode = http.GET();
      esp_task_wdt_reset(); // Feed watchdog after HTTP operation

      if (httpResponseCode == 200)
      {
        DynamicJsonDocument doc(2048);
        deserializeJson(doc, http.getString());

        if (!doc.isNull() && doc.size() > 0)
        {
          String latStr = doc[0]["lat"];
          String lonStr = doc[0]["lon"];

          Serial.println("üåé Found City Location:");
          Serial.println("Latitude: " + latStr);
          Serial.println("Longitude: " + lonStr);

          latitude = latStr.toFloat();
          longitude = lonStr.toFloat();
        }
        else
        {
          Serial.println("‚ùå No matching city found!");
        }
      }
      else
      {
        Serial.print("‚ùå HTTP Request failed, code: ");
        Serial.println(httpResponseCode);
      }

      http.end();
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    void fetchWeather()
    {
      if (ESP.getFreeHeap() < MIN_HEAP_REQUIRED)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      if (savedCity == "")
      {
        Serial.println("‚ùå City not set, skipping weather fetch.");
        return;
      }

      String weatherURL = "https://api.open-meteo.com/v1/forecast?latitude=" + String(latitude, 6) +
                          "&longitude=" + String(longitude, 6) +
                          "&current=temperature_2m,weather_code&timezone=auto";

      HTTPClient http;
      http.setTimeout(2000);      // Prevent hanging
      http.setConnectTimeout(1500); // Connection timeout
      http.useHTTP10(true);       // Use HTTP/1.0 for better stability
      http.setReuse(false);       // Don't reuse connection
      http.begin(weatherURL);
      
      esp_task_wdt_reset(); // Feed watchdog before HTTP operation
      int httpCode = http.GET();
      esp_task_wdt_reset(); // Feed watchdog after HTTP operation

      if (httpCode == 200)
      {
        String payload = http.getString();
        if (payload.length() == 0)
        {
          Serial.println("‚ùå Empty weather payload received!");
          http.end();
          return;
        }

        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);

        if (!error)
        {
          float temp = doc["current"]["temperature_2m"];
          int weatherCode = doc["current"]["weather_code"];
          String condition = mapWeatherCode(weatherCode);

          temperature = (int)temp;
          weatherCondition = condition;
          Serial.printf("‚úÖ Updated Weather: %d¬∞C | Condition: %s\n", temperature, weatherCondition.c_str());
          Serial.print("üå°Ô∏è Temperature: ");
          Serial.println(temperature);
          Serial.println("üå¶Ô∏è Condition: " + weatherCondition);
        }
        else
        {
          Serial.println("‚ùå Failed to parse weather JSON");
        }
      }
      else
      {
        Serial.println("‚ùå Weather fetch failed, HTTP code: " + String(httpCode));
      }

      http.end(); // ‚úÖ Always clean up!
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    // Blocking helper to show reboot messages reliably
    void showRebootMessages()
    {
      Serial.println("üíæ Showing SETTINGS SAVED message...");
      P.displayClear(); // Clear old text first
      P.displayZoneText(ZONE_UPPER, "SETTINGS", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(ZONE_LOWER, "SAVED!", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayReset(ZONE_UPPER);
      P.displayReset(ZONE_LOWER);
      
      unsigned long start = millis();
      while (millis() - start < 2000)
      {
        esp_task_wdt_reset();
        P.displayAnimate();
        delay(10);
      }
      
      Serial.println("üîÑ Showing REBOOTING message...");
      P.displayZoneText(ZONE_UPPER, "REBOOTING", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(ZONE_LOWER, "NOW...", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayReset(ZONE_UPPER);
      P.displayReset(ZONE_LOWER);
      
      start = millis();
      while (millis() - start < 2000)
      {
        esp_task_wdt_reset();
        P.displayAnimate();
        delay(10);
      }
    }

    // Setup of device

    void setup()
    {
      Serial.begin(115200);
      delay(100); // Allow serial to stabilize
      
      // üî• CRITICAL SAFETY: Initialize LED Matrix FIRST to prevent power surge and fire hazard
      // Must happen BEFORE any other operations (SPIFFS, WiFi, etc.)
      Serial.println("üõ°Ô∏è SAFETY: Initializing LED Matrix immediately...");
      
      // Initialize SPI and LED driver chips with safe defaults
      P.begin(MAX_ZONES);
      delay(50); // Give MAX7219 chips time to initialize properly
      
      P.setZone(ZONE_LOWER, 0, ZONE_SIZE - 1);
      P.setZone(ZONE_UPPER, ZONE_SIZE, MAX_DEVICES - 1);
      P.setFont(nullptr);
      
      // Set to shutdown mode first, then configure safely
      // Put MAX7219 into shutdown immediately (LEDs OFF)
      P.displayShutdown(true);
      delay(10);

      // Wake briefly so register writes actually apply
      P.displayShutdown(false);
      delay(10);

      // Clear any random latched data
      P.displayClear();
      // Set safe, dim startup brightness
      P.setIntensity(ZONE_UPPER, 1);
      P.setIntensity(ZONE_LOWER, 1);
      // Clear again to ensure blank display with brightness applied
      P.displayClear();
      
      Serial.println("‚úÖ LED Matrix safely initialized at brightness 1");
      
      // üêï Initialize watchdog timer EARLY to prevent crashes during setup
      Serial.println("üêï Initializing Watchdog Timer...");
      esp_task_wdt_config_t wdt_config = {
          .timeout_ms = 12000,                             // 12 seconds
          .idle_core_mask = (1 << portNUM_PROCESSORS) - 1, // All cores
          .trigger_panic = true                            // Reset if not fed in time
      };
      esp_task_wdt_init(&wdt_config);
      esp_task_wdt_add(NULL); // Add current task to WDT
      Serial.println("‚úÖ Watchdog Timer initialized");
      
      Serial.println("üöÄ Starting STACKSWORTH Matrix Setup...");

      //Adding MAC Address to ID
      macID = getShortMAC();
      Serial.println("üÜî MAC Fragment: " + macID);

      prefs.begin("device", false);
      prefs.putString("shortMAC", macID);
      prefs.end();

    

      // Monitor available heap memory
      Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
      Serial.printf("Minimum free heap: %d bytes\n", ESP.getMinFreeHeap());
      Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());

      // üóÇÔ∏è Mount SPIFFS
      Serial.println("üóÇÔ∏è Mounting SPIFFS...");
      if (!SPIFFS.begin(true))
      {
        Serial.println("‚ùå Failed to mount SPIFFS");
        return;
      }
      Serial.println("‚úÖ SPIFFS mounted successfully!");

      if (!SPIFFS.exists("/STACKS_Wifi_Portal.html.gz"))
      {
        Serial.println("‚ùå HTML file NOT found");
      }
      else
      {
        Serial.println("‚úÖ Custom HTML file found");
      }

      // Try WiFi first, fallback if needed
      Serial.println("üì° Loading saved WiFi and settings...");
      loadSavedSettingsAndConnect();

      randomSeed(esp_random());

      // Show IP/Portal immediately (if WiFi not connected)
      if (!wifiConnected)
      {
        // Set a visible brightness for portal screen
        Serial.println("üí° Setting brightness for portal screen...");
        P.setIntensity(ZONE_UPPER, 3);  // Medium-low brightness for setup
        P.setIntensity(ZONE_LOWER, 3);
        
        // Show portal status and IP address immediately - NO welcome animation
        Serial.println("üì° Showing portal status and IP...");
        IPAddress apIP = WiFi.softAPIP();
        String ipDisplay = apIP.toString();
        P.displayZoneText(ZONE_UPPER, "OPEN PORTAL", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
        P.displayZoneText(ZONE_LOWER, ipDisplay.c_str(), PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
        P.displayReset(ZONE_UPPER);
        P.displayReset(ZONE_LOWER);
        
        // Pump display once to lock it in
        for (int i = 0; i < 10; i++) {
          P.displayAnimate();
          delay(10);
        }
        
        apMsgShown = true;
        Serial.println("‚úÖ Portal screen displayed - ready for setup");
      }

      // Now restore user's preferred brightness after welcome screens
      Serial.println("üí° Restoring user brightness settings...");
      P.setIntensity(ZONE_UPPER, BRIGHTNESS);
      P.setIntensity(ZONE_LOWER, BRIGHTNESS);
      
      Serial.printf("üí° Brightness restored to: %d/15 for all zones\n", BRIGHTNESS);

      // üïí Time Config - only set default if not already configured in loadSavedSettingsAndConnect()
      if (!wifiConnected) {
        Serial.println("üïí Configuring default timezone (Mountain Time)...");
        configTzTime(TIMEZONE_STRINGS[11], ntpServer); // Default to Mountain Time
      }

      // Serve Custom HTML File
      server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
                {
  if (SPIFFS.exists("/STACKS_Wifi_Portal.html.gz")) {
    AsyncWebServerResponse *response = request->beginResponse(SPIFFS, "/STACKS_Wifi_Portal.html.gz", "text/html");
    response->addHeader("Content-Encoding", "gzip"); // Inform the browser that the file is GZIP-compressed
    request->send(response);
  } else {
    request->send(404, "text/plain", "Custom HTML file not found");
  } });

      // üìù Handle Save Form Submission
      server.on("/save", HTTP_POST, [](AsyncWebServerRequest *request)
                {
  if (request->hasParam("ssid", true) && request->hasParam("password", true)) {
    // üîê Open prefs first so we can keep existing values if user leaves fields blank
    prefs.begin("stacksworth", false);

    String ssid = request->getParam("ssid", true)->value();
    String password = request->getParam("password", true)->value();
    String city = request->getParam("city", true)->value();
    String timezone = request->getParam("timezone", true)->value();
    String currency = request->getParam("currency", true)->value();
    String theme = request->getParam("theme", true)->value();
    String toptext = request->getParam("toptext", true)->value();
    String bottomtext = request->getParam("bottomtext", true)->value();
    String tempunit = request->getParam("tempunit", true)->value();
    String devicename = request->getParam("devicename", true)->value();
    String brightness = request->getParam("brightness", true)->value();

    // ‚úÖ If user left SSID/PW blank, keep existing saved values
    // This prevents accidental Wi-Fi wipe when reopening Matrix.local to change other settings.
    ssid.trim();
    password.trim();

    if (ssid.length() == 0) {
      ssid = prefs.getString("ssid", "");
    }
    if (password.length() == 0) {
      password = prefs.getString("password", "");
    }

    // Validate and limit custom text to 11 characters
    if (toptext.length() > 11) toptext = toptext.substring(0, 11);
    if (bottomtext.length() > 11) bottomtext = bottomtext.substring(0, 11);
    // Validate and limit device name to 20 characters
    if (devicename.length() > 20) devicename = devicename.substring(0, 20);

    Serial.println("‚úÖ Saving WiFi Settings:");
    Serial.println("SSID: " + ssid);
    Serial.println("Password: (hidden)");
    Serial.println("City: " + city);
    Serial.println("Timezone: " + timezone);
    Serial.println("Currency: " + currency);
    Serial.println("Theme: " + theme);
    Serial.println("Custom Top: " + toptext);
    Serial.println("Custom Bottom: " + bottomtext);
    Serial.println("Temperature Unit: " + tempunit);
    Serial.println("Device Name: " + devicename);
    Serial.println("Brightness: " + brightness);
    prefs.putString("ssid", ssid);
    prefs.putString("password", password);
    prefs.putString("city", city);
    prefs.putString("currency", currency);                          // üåç Store currency
    prefs.putString("theme", theme);                                // üé® Store theme
    prefs.putString("toptext", toptext);                            // üìù Store custom top text
    prefs.putString("bottomtext", bottomtext);                      // üìù Store custom bottom text
    prefs.putString("tempunit", tempunit);                          // üå°Ô∏è Store temperature unit
    prefs.putString("devicename", devicename);                      // üÜî Store device nickname
    prefs.putUChar("brightness", brightness.toInt());              // üí° Store brightness
    
    // üìä Store display options (show0-show14)
    for (int i = 0; i < 15; i++) {
      String key = "show" + String(i);
      String value = request->hasParam(key, true) ? request->getParam(key, true)->value() : "0";
      prefs.putUChar(key.c_str(), value.toInt());
      Serial.printf("Display %d: %s\n", i, value.c_str());
    }
    
    prefs.putInt("timezone", timezone.toInt());
    prefs.end();
    Serial.println("‚úÖ Settings saved to NVS!");
    
    // ‚úÖ IMMEDIATELY APPLY CHANGES (don't wait for reboot)
    savedBrightness = brightness.toInt();
    savedTempUnit = tempunit;
    savedCity = city;
    savedCurrency = currency;
    savedTopText = toptext;
    savedBottomText = bottomtext;
    savedTheme = theme;
    
    // üîÑ Reload displayEnabled array from NVS
    prefs.begin("stacksworth", true);  // Open in read-only mode
    for (int i = 0; i < 15; i++) {
      String key = "show" + String(i);
      displayEnabled[i] = prefs.getUChar(key.c_str(), 1) == 1;
    }
    prefs.end();
    
    // üí° Apply brightness immediately
    setBrightness(savedBrightness);


    // ‚úÖ SEND HTTP 200 RESPONSE FIRST
    request->send(200, "text/plain", "Settings saved! Rebooting...");

    // Show reboot messages and restart
    showRebootMessages();
    ESP.restart();
  } else {
    Serial.println("‚ùå Missing parameters in form submission!");
    request->send(400, "text/plain", "Missing parameters");
  } });


      // Serve device info to the portal
      server.on("/deviceinfo", HTTP_GET, [](AsyncWebServerRequest *request) {
        String info = "{\"macid\":\"" + getShortMAC() + "\",";
        info += "\"devicename\":\"" + savedDeviceName + "\",";
        info += "\"version\":\"v2.0.46\"}";
        request->send(200, "application/json", info);
      });
      
      // Legacy endpoint for backward compatibility
      server.on("/macid", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send(200, "text/plain", getShortMAC());
      });
      
      // üîç Identify endpoint - blink display to show which device user is configuring
      server.on("/identify", HTTP_GET, [](AsyncWebServerRequest *request) {
        Serial.println("üîç Identify button pressed - showing portal active message");
        
        // Show identification message on display
        P.displayClear();
        P.displayZoneText(ZONE_UPPER, "PORTAL", PA_CENTER, 0, 5000, PA_FADE, PA_FADE);
        P.displayZoneText(ZONE_LOWER, "ACTIVE", PA_CENTER, 0, 5000, PA_FADE, PA_FADE);
        P.synchZoneStart();
        
        // Wait for animation to complete
        unsigned long startTime = millis();
        while (millis() - startTime < 5000) {
          P.displayAnimate();
          esp_task_wdt_reset();
          delay(10);
        }
        
        request->send(200, "text/plain", "Device identified!");
        Serial.println("‚úÖ Identify animation complete");
      });

      // Brightness control endpoint
      server.on("/brightness", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("level")) {
          String levelStr = request->getParam("level")->value();
          uint8_t newBrightness = levelStr.toInt();
          if (newBrightness >= 1 && newBrightness <= 15) {
            setBrightness(newBrightness);
            request->send(200, "text/plain", "Brightness set to " + String(BRIGHTNESS));
          } else {
            request->send(400, "text/plain", "Invalid brightness level. Use 1-15");
          }
        } else {
          request->send(200, "text/plain", "Current brightness: " + String(BRIGHTNESS) + "/15");
        }
      });


      // Captive Portal Redirect
      server.onNotFound([](AsyncWebServerRequest *request)
                        { request->redirect("/");
                        });

      // Start Web Server
      Serial.println("üåê Starting Async Web Server...");
      delay(2000); // üïí Let WiFi fully stabilize first
      server.begin();
      Serial.println("üåç Async Web server started");
      delay(2000); // üïí Let server stabilize after starting

      // üåê Setup mDNS with smart hostname (nickname-based or MAC-based fallback)
      String mdnsHostname = "Matrix";  // Default
      
      if (savedDeviceName.length() > 0) {
        // User has named their device - use sanitized nickname
        String sanitized = savedDeviceName;
        sanitized.replace(" ", "-");  // "Living Room" -> "Living-Room"
        sanitized.replace("_", "-");
        // Remove any non-alphanumeric chars except hyphens
        for (int i = sanitized.length() - 1; i >= 0; i--) {
          char c = sanitized.charAt(i);
          if (!isalnum(c) && c != '-') {
            sanitized.remove(i, 1);
          }
        }
        if (sanitized.length() > 0) {
          mdnsHostname = "Matrix-" + sanitized;
        }
      } else {
        // No nickname - use MAC-based hostname for uniqueness
        mdnsHostname = "Matrix-" + macID;
      }
      
      if (!MDNS.begin(mdnsHostname.c_str())) {
        Serial.println("‚ùå Error setting up mDNS responder!");
      } else {
        Serial.printf("‚úÖ mDNS responder started - Access at http://%s.local\n", mdnsHostname.c_str());
        Serial.println("‚úÖ Also accessible at http://Matrix.local (if first/only device)");
        MDNS.addService("http", "tcp", 80);
      }

      bootMs = millis();

      // Initialize with last known values or sensible first-boot defaults
      Serial.println("üîß Loading cached values or setting first-boot defaults...");
      
      // Try to load last known good values from preferences
      prefs.begin("cache", true);  // read-only mode
      String lastBtcText = prefs.getString("btcText", "Connecting");
      String lastBlockText = prefs.getString("blockText", "Syncing");
      String lastFeeText = prefs.getString("feeText", "Checking");
      String lastSatsText = prefs.getString("satsText", "Updating");
      String lastChangeText = prefs.getString("changeText", "Fetching");
      String lastAthText = prefs.getString("athText", "Refreshing");
      String lastDaysAthText = prefs.getString("daysAthText", "Updating");
      String lastHashrateText = prefs.getString("hashrateText", "Checking");
      String lastCircSupplyText = prefs.getString("circSupplyText", "Counting");
      String lastMinerName = prefs.getString("minerName", "Discovering");
      prefs.end();
      
      // Apply cached or first-boot values
      strncpy(btcText, lastBtcText.c_str(), sizeof(btcText));
      strncpy(blockText, lastBlockText.c_str(), sizeof(blockText));
      strncpy(feeText, lastFeeText.c_str(), sizeof(feeText));
      strncpy(satsText, lastSatsText.c_str(), sizeof(satsText));
      strncpy(satsText2, "Updating", sizeof(satsText2));
      strncpy(timeText, "Syncing", sizeof(timeText));
      strncpy(dateText, "...", sizeof(dateText));
      strncpy(dayText, "Starting", sizeof(dayText));
      strncpy(hashrateText, lastHashrateText.c_str(), sizeof(hashrateText));
      strncpy(circSupplyText, lastCircSupplyText.c_str(), sizeof(circSupplyText));
      strncpy(circPercentText, "/21 Million", sizeof(circPercentText));
      strncpy(changeText, lastChangeText.c_str(), sizeof(changeText));
      strncpy(athText, lastAthText.c_str(), sizeof(athText));
      strncpy(daysAthText, lastDaysAthText.c_str(), sizeof(daysAthText));
      minerName = lastMinerName;
      
    
      // ‚ö†Ô∏è CRITICAL: Cannot do HTTP calls in setup() - causes lwIP threading assertion
      // Initial fetch will happen in first loop() iteration instead
      Serial.println("‚úÖ Setup complete - initial data fetch will happen in loop()");

      // üëá  Manually trigger first animation cycle!
      cycle = 0;                                              // Start at first data set
      lastApiCall = millis() - FETCH_INTERVAL;                // Force immediate fetch
      lastWeatherUpdate = millis() - WEATHER_UPDATE_INTERVAL; // Force weather update soon
      lastNTPUpdate = millis() - NTP_UPDATE_INTERVAL;         // Force NTP update soon

      pinMode(BUTTON_PIN, INPUT_PULLUP);  //added this for the Smash Buy Button!!!

      bootMs = millis();
    }

    

    
    void loop()
    {
      esp_task_wdt_reset();           // Reset watchdog
      dnsServer.processNextRequest(); // Handle captive portal DNS magic

      // üöÄ INITIAL FETCH - Run once on first loop iteration (safe for lwIP)
      // ‚ö†Ô∏è CONSERVATIVE: Only try SatoNak APIs, skip fallbacks to prevent WDT crashes
      // If SatoNak is down, we use cached values and retry in normal loop cycle
      if (wifiConnected && !initialFetchDone && !apMode) {
        Serial.println("üåç Fetching initial data (first loop iteration - SatoNak only, no fallbacks)...");
        
        unsigned long now = millis();
        
        // Try each API but don't hang if they fail - cached data will be used
        esp_task_wdt_reset(); fetchHeightFromSatoNak(); lastBlockHeightFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchMinerFromSatoNak(); lastMinerFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchPriceFromSatoNak(); lastPriceFetch = now;  // Direct SatoNak only, no CoinGecko fallback
        delay(500);
        esp_task_wdt_reset(); fetchChange24hFromSatoNak(); lastChange24hFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchFeeFromSatoNak(); lastFeeFetch = now;  // Direct SatoNak only, no mempool.space fallback
        delay(500);
        esp_task_wdt_reset(); fetchHashrateFromSatoNak(); lastHashrateFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchCircSupplyFromSatoNak(); lastCircSupplyFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchAthFromSatoNak(); lastAthFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchDaysSinceAthFromSatoNak(); lastDaysAthFetch = now;
        delay(500);
        esp_task_wdt_reset(); fetchTime();
        delay(100);
        esp_task_wdt_reset(); fetchLatLonFromCity();
        delay(100);
        esp_task_wdt_reset(); fetchWeather();

        lastFetchTime = millis();
        Serial.println("‚úÖ Initial data fetch complete! (Fallback APIs will retry in normal loop if needed)");
        saveDisplayCache();
        
        // Show Connection Success Message
        Serial.println("üì¢ Displaying WiFi connected message on Matrix...");
        P.displayZoneText(ZONE_UPPER, "WIFI", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
        P.displayZoneText(ZONE_LOWER, "CONNECTED", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
        delay(2000);
        
        initialFetchDone = true;
      }

      // If in AP portal mode, keep showing PORTAL OPEN
      if (apMode && WiFi.status() != WL_CONNECTED)
      {
        feedWDT(); // Feed watchdog before processing
        
        // Keep the portal display active (re-set if needed)
        if (!apMsgShown)
        {
          IPAddress apIP = WiFi.softAPIP();
          String ipDisplay = apIP.toString();
          P.displayZoneText(ZONE_UPPER, "OPEN PORTAL", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
          P.displayZoneText(ZONE_LOWER, ipDisplay.c_str(), PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
          P.displayReset(ZONE_UPPER);
          P.displayReset(ZONE_LOWER);
          apMsgShown = true;
        }
        
        P.displayAnimate();
        feedWDT(); // Feed watchdog after display
        delay(50); // Shorter delay to keep WDT happy
        return;
      }
      else if (apMode && wifiConnected)
      {
        // Exit portal mode - clean up DNS server
        Serial.println("‚úÖ Exiting AP mode, stopping DNS server...");
        dnsServer.stop();
        apMode = false;
        apMsgShown = false;
      }

      // üåê WiFi RESILIENCE MONITOR (check every 10 seconds)
      // Strategy: Keep displaying cached data, only fall back to AP mode after extended failure
      static unsigned long lastWiFiCheck = 0;
      static bool reconnecting = false;
      unsigned long now = millis();
      
      if (!apMode && savedSSID.length() > 0 && now - lastWiFiCheck >= 10000) {
        lastWiFiCheck = now;
        
        if (WiFi.status() != WL_CONNECTED) {
          // WiFi is disconnected
          if (!reconnecting) {
            // Just noticed disconnection
            Serial.println("‚ö†Ô∏è WiFi disconnected! Continuing with cached data, attempting reconnect...");
            wifiDisconnectedAt = (wifiDisconnectedAt == 0) ? now : wifiDisconnectedAt;
            reconnecting = true;
            wifiConnected = false;
          }
          
          // Check if we've been disconnected too long (1 hour)
          if (hasEverConnected && (now - wifiDisconnectedAt >= WIFI_FALLBACK_TIMEOUT)) {
            Serial.println("üö® WiFi disconnected for 1+ hour. Falling back to AP mode for reconfiguration.");
            startAccessPoint();
            return; // Exit to AP mode
          }
          
          // Try reconnecting (non-blocking)
          if (now % 10000 < 100) {  // Attempt every 10 seconds
            Serial.println("üîÑ Retrying WiFi connection...");
            WiFi.begin(savedSSID.c_str(), savedPassword.c_str());
          }
          
        } else if (reconnecting) {
          // WiFi reconnected!
          Serial.println("‚úÖ WiFi reconnected successfully!");
          reconnecting = false;
          wifiConnected = true;
          wifiDisconnectedAt = 0; // Reset disconnection timer
        }
      }

// üõ†Ô∏è Smash Buy Button Polling (Debounced)
static bool lastButtonState = HIGH;
bool currentButtonState = digitalRead(BUTTON_PIN);

if (lastButtonState == HIGH && currentButtonState == LOW) {
  // Falling edge: button was released, now pressed
  Serial.println("üö® SMASH BUY Button Pressed!");
  buttonPressed = true;
}

lastButtonState = currentButtonState;

// USED FOR RANDOM PHRASES
if (buttonPressed) {
  buttonPressed = false;  // consume the event so it fires once

int idx = random(NUM_PHRASES);
const char* topLine    = PHRASES[idx][0];
const char* bottomLine = PHRASES[idx][1];

// Optional: small press lockout to avoid double-fires on long press/bounce
static unsigned long pressLockUntil = 0;
if (millis() < pressLockUntil) return;
pressLockUntil = millis() + 600; // 0.6s cooldown

// Show the message (nice and clean fade). Use your zone IDs as you already do.
// If you prefer, you can show the same phrase on both lines for impact.
P.displayClear();
P.displayZoneText(1, topLine,    PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
P.displayZoneText(0, bottomLine, PA_CENTER, 0, 2500, PA_FADE, PA_FADE);

// Let the animation finish while keeping WDT happy (ESP32)
while (!P.displayAnimate()) {
  esp_task_wdt_reset();
  delay(10);
}

P.displayClear();
P.synchZoneStart();
esp_task_wdt_reset(); // Feed watchdog after animation complete
Serial.print("üéØ Smash Buy: ");
Serial.print(topLine);
Serial.print(" / ");
Serial.println(bottomLine);

}




  unsigned long currentMillis = millis();
      

      // ‚úÖ Monitor heap health every 60 seconds
      static unsigned long lastMemoryCheck = 0;
      static unsigned long lastHeapLog = 0;
      if (currentMillis - lastMemoryCheck >= 60000)
      {
        Serial.printf("üß† Free heap: %d | Min ever: %d\n", ESP.getFreeHeap(), ESP.getMinFreeHeap());
        lastMemoryCheck = currentMillis;
      }

      // üö® Auto-reboot if heap drops too low
      if (ESP.getFreeHeap() < 140000)
      {
        Serial.println("üö® CRITICAL: Free heap dangerously low. Rebooting to recover...");
        delay(1000); // Give time for message to print
        ESP.restart();
      }

      // ‚è∞ Fetch Time every 1 minute
      static unsigned long lastTimeFetch = 0;
      if (currentMillis - lastTimeFetch >= 60000)
      {
        fetchTime();
        lastTimeFetch = currentMillis;
      }

      // ‚îÄ‚îÄ HTTP scheduler: serialize network calls to avoid overlap
if (WiFi.status() == WL_CONNECTED) {
  uint32_t now = millis();

  // 1) BTC every BTC_INTERVAL
  if (now - lastBTC >= BTC_INTERVAL) {
    esp_task_wdt_reset(); // Feed watchdog before network operations
    fetchBitcoinData();
    lastBTC = now;
    saveDisplayCache(); // Save after successful price update
    esp_task_wdt_reset(); // Feed watchdog after network operations
  }
  // 2) Fee at +offset
  else if ((now - lastFee >= (FEE_INTERVAL + FEE_OFFSET)) && (now >= bootMs + FEE_OFFSET)) {
    esp_task_wdt_reset(); // Feed watchdog before network operations
    fetchFeeRate();
    lastFee = now;
    esp_task_wdt_reset(); // Feed watchdog after network operations
  }
  // 3) Block height at +offset
  else if ((now - lastBlock >= (BLOCK_INTERVAL + BLOCK_OFFSET)) && (now >= bootMs + BLOCK_OFFSET)) {
    esp_task_wdt_reset(); // Feed watchdog before network operations
    fetchBlockHeight();
    fetchMinerFromSatoNak();
    fetchHashrateFromSatoNak();
    fetchCircSupplyFromSatoNak();
    fetchAthFromSatoNak();
    fetchDaysSinceAthFromSatoNak();
    fetchChange24hFromSatoNak();
    lastBlock = now;
    saveDisplayCache(); // Save after successful data updates
    esp_task_wdt_reset(); // Feed watchdog after network operations
  }
  // 4) Weather seldom, with a small offset
  else if ((now - lastWeather >= (WEATHER_INTERVAL + WEATHER_OFFSET)) && (now >= bootMs + WEATHER_OFFSET)) {
    esp_task_wdt_reset(); // Feed watchdog before network operations
    fetchWeather();
    lastWeather = now;
    esp_task_wdt_reset(); // Feed watchdog after network operations
  }
}



      // üñ•Ô∏è Rotate screens
  if (P.displayAnimate()) {
    Serial.print("üñ•Ô∏è Displaying screen: ");
    Serial.println(displayCycle);

    switch (displayCycle) {
      case 0: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying BLOCK screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "BLOCK", blockText); 
        P.displayZoneText(ZONE_UPPER, "BLOCK",   PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, blockText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 1: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying MINER screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "MINER", minerName.c_str());
        P.displayZoneText(ZONE_UPPER, "MINED BY", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, minerName.c_str(), PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 2: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying CIRCULATING SUPPLY screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", circSupplyText, circPercentText);
        P.displayZoneText(ZONE_UPPER, circSupplyText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, circPercentText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 3: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        String currentFiat = getCurrentFiatCode();
        static char priceLabel[48];  // Increased buffer size for safety
        snprintf(priceLabel, sizeof(priceLabel), "%s PRICE", currentFiat.c_str());
        Serial.println("üñ•Ô∏è Displaying " + currentFiat + " PRICE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", priceLabel, btcText);
        Serial.printf("üîç DEBUG: btcText='%s', length=%d\n", btcText, strlen(btcText));
        P.displayZoneText(ZONE_UPPER, priceLabel, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, btcText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear();
        P.synchZoneStart();
        break;
      } 

          
      case 4: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying 24H CHANGE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "24H CHANGE", changeText);
        P.displayZoneText(ZONE_UPPER, "24H CHANGE", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, changeText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear();
        P.synchZoneStart();
        break;
      }

      case 5: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying ATH PRICE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "ATH", athText);
        P.displayZoneText(ZONE_UPPER, "ATH", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, athText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 6: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying DAYS SINCE ATH screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", daysAthText, "Since ATH");
        P.displayZoneText(ZONE_UPPER, daysAthText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, "Since ATH", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 7: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        String currentFiat = getCurrentFiatCode();
        static char satsLabel[48];  // Increased buffer size for safety
        snprintf(satsLabel, sizeof(satsLabel), "SATS/%s", currentFiat.c_str());
        Serial.println("üñ•Ô∏è Displaying SATS per " + currentFiat + " screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", satsLabel, satsText);
        P.displayZoneText(ZONE_UPPER, satsLabel, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, satsText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization  
        break;
      }
        
      case 8: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying FEE RATE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "FEE RATE", feeText);
        P.displayZoneText(ZONE_UPPER, "FEE RATE", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, feeText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 9: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying HASHRATE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "HASHRATE", hashrateText);
        P.displayZoneText(ZONE_UPPER, "HASHRATE", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, hashrateText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

        
      case 10: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying TIME and City screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "TIME", timeText);
        P.displayZoneText(ZONE_UPPER, savedCity.c_str(), PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, timeText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

        
      case 11: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying DAY/DATE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", dayText, dateText);
        P.displayZoneText(ZONE_UPPER, dayText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, dateText, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

        
      case 12: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying WEATHER screen...");
        static char tempDisplay[16];
        
        // üå°Ô∏è Convert temperature based on user's preference
        int displayTemp = temperature;
        char tempUnit = 'C';
        if (savedTempUnit == "F") {
          displayTemp = (int)((temperature * 9.0 / 5.0) + 32); // Convert C to F
          tempUnit = 'F';
        }
        
        snprintf(tempDisplay, sizeof(tempDisplay), (displayTemp >= 0) ? "+%d%c" : "%d%c", displayTemp, tempUnit);
        String cond = weatherCondition;
        cond.replace("_", " ");
        cond.toLowerCase();
        cond[0] = toupper(cond[0]);
        static char condDisplay[32];
        strncpy(condDisplay, cond.c_str(), sizeof(condDisplay));
        condDisplay[sizeof(condDisplay) - 1] = '\0';

        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", tempDisplay, condDisplay);
        P.displayZoneText(ZONE_UPPER, tempDisplay, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, condDisplay, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      

      case 13: {
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        Serial.println("üñ•Ô∏è Displaying MOSCOW TIME screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "MOSCOW TIME", satsText2);
        P.displayZoneText(ZONE_UPPER, "MOSCOW TIME", PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayZoneText(ZONE_LOWER, satsText2, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization  
        break;
      }

      case 14: {// Custom user message or default Satoshi tribute
        textEffect_t effectIn, effectOut;
        getThemeEffects(effectIn, effectOut);
        
        // Use custom text if provided, otherwise show Satoshi tribute
        const char* topLine = (savedTopText.length() > 0) ? savedTopText.c_str() : "Satoshi";
        const char* bottomLine = (savedBottomText.length() > 0) ? savedBottomText.c_str() : "Nakamoto";
        
        Serial.printf("üî§ Displaying custom message: %s (Top), %s (Bottom)\n", topLine, bottomLine);
        P.displayZoneText(ZONE_UPPER, topLine, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut); 
        P.displayZoneText(ZONE_LOWER, bottomLine, PA_CENTER, SCROLL_SPEED, 10000, effectIn, effectOut); 
        P.displayClear();
        P.synchZoneStart();
        break;
      }
    }

      Serial.println("‚úÖ Screen update complete.");
      
      // üìä Advance to next enabled display cycle with safety checks
      uint8_t attempts = 0;
      bool foundEnabled = false;

      do {
        displayCycle = (displayCycle + 1) % 15;
        attempts++;
        
        if (displayEnabled[displayCycle]) {
          foundEnabled = true;
          break;
        }
        
        // Safety: If we've tried all 15 cases and found nothing, force-enable case 0
        if (attempts >= 15) {
          Serial.println("‚ö†Ô∏è All displays disabled! Force-enabling Case 0 (Block Height) as failsafe.");
          displayEnabled[0] = true;  // Force-enable Block Height display
          displayCycle = 0;
          foundEnabled = true;
          break;
        }
      } while (!foundEnabled);
      
    }
  }
