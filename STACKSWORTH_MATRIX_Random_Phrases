// üöÄ STACKSWORTH_MATRIX_MASTER: Dual_Row SCROLL_LEFT 20
#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>
#include <WiFiManager.h> 
#include <HTTPClient.h>
#include <WiFiClient.h>
#include <ArduinoJson.h>
#include "esp_task_wdt.h"
#include "Font_Data.h" // Optional, if using custom fonts
#include "time.h"
#include <FS.h>
#include <SPIFFS.h>
#include <ESPAsyncWebServer.h>
#include <AsyncTCP.h>
#include <WiFi.h>
#include <esp_wifi.h>  // Needed for esp_read_mac
#include "esp_system.h"
#include <DNSServer.h>
DNSServer dnsServer;
#include <Preferences.h>
Preferences prefs;


// retrieve and store the MAC
String getShortMAC() {
  uint8_t mac[6];
  esp_wifi_get_mac(WIFI_IF_STA, mac);  // Get STA interface MAC
  char shortID[7];
  sprintf(shortID, "%02X%02X%02X", mac[3], mac[4], mac[5]);  // last 3 bytes (6 hex chars)
  return String(shortID);
}

String macID;



bool wifiConnected = false;
bool buttonPressed = false;

String savedSSID;
String savedPassword;
String savedCity;
int savedTimezone = -99;


// Fetch and Display Cycles
uint8_t fetchCycle = 0;   // üëà for rotating which API we fetch
uint8_t displayCycle = 0; // üëà for rotating which screen we show

// initializes the server so we can later attach our custom HTML page routes
AsyncWebServer server(80);

static WiFiClient httpClient;

// üåç API Endpoints
const char* BTC_API = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true";;
const char *BLOCK_API = "https://blockchain.info/q/getblockcount";
const char *FEES_API = "https://mempool.space/api/v1/fees/recommended";
const char *MEMPOOL_BLOCKS_API = "https://mempool.space/api/blocks";
const char *BLOCKSTREAM_TX_API_BASE = "https://blockstream.info/api/block/";

// ---- Smash Buy phrases split into TOP / BOTTOM lines ----
const char* PHRASES[][2] = {
  { "SMASH",           "BUY!" },
  { "DON'T TRUST",     "VERIFY!" },
  { "STACK",           "SATS" },
  { "RUN A",           "NODE" },
  { "NOT YOUR",        "KEYS" },
  { "FIX THE",         "MONEY" },
  { "STAY",            "HUMBLE" },
  { "OPT",             "OUT" },
  { "LOW TIME",       "PREFERENCE" },  // fun variation
  { "INFINITE",        "GAME" },
  { "HARDER",          "MONEY" },
  { "BITCOIN",         "> FIAT" },
  { "LET'S",            "GO" }
};
#define NUM_PHRASES (sizeof(PHRASES) / sizeof(PHRASES[0]))

String mapWeatherCode(int code)
{
  if (code == 0)
    return "Sunny";
  else if (code == 1)
    return "Mostly Sunny";
  else if (code == 2)
    return "Partly Cloudy";
  else if (code == 3)
    return "Cloudy";
  else if (code >= 45 && code <= 48)
    return "Foggy";
  else if (code >= 51 && code <= 57)
    return "Drizzle";
  else if (code >= 61 && code <= 67)
    return "Rain";
  else if (code >= 71 && code <= 77)
    return "Snowy";
  else if (code >= 80 && code <= 82)
    return "Showers";
  else if (code >= 85 && code <= 86)
    return "Snow Showers";
  else if (code >= 95 && code <= 99)
    return "Thunderstorm";
  else
    return "Unknown";
}

// Time Config
const char *ntpServer = "pool.ntp.org";
long gmtOffset_sec = -7 * 3600;
int daylightOffset_sec = 3600;

// Global Data Variables
int btcPrice = 0, blockHeight = 0, feeRate = 0, satsPerDollar = 0;
char btcText[16], blockText[16], feeText[16], satsText[16];
char timeText[16], dateText[16], dayText[16];
float latitude = 0.0;
float longitude = 0.0;
String weatherCondition = "Unknown";
int temperature = 0;
float btcChange24h = 0.0;
char changeText[16];

String formatWithCommas(int number)
{
  String numStr = String(number);
  String result = "";
  int len = numStr.length();
  for (int i = 0; i < len; i++)
  {
    if (i > 0 && (len - i) % 3 == 0)
      result += ",";
    result += numStr[i];
  }
  return result;
}

// LED Matrix Config
#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_ZONES 2
#define ZONE_SIZE 8
#define MAX_DEVICES (MAX_ZONES * ZONE_SIZE)
#define SCROLL_SPEED 20
#define FETCH_INTERVAL 120000

#define ZONE_LOWER 0
#define ZONE_UPPER 1

#define CLK_PIN 18
#define DATA_PIN 23
#define CS_PIN 5
#define BUTTON_PIN 25   //Pin for Smash Buy Button

MD_Parola P = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);
// int brightnessLevel = 6;  // 0 = dimmest, 15 = brightest
unsigned long lastFetchTime = 0;
uint8_t cycle = 0;             // üî• Needed for animation control
unsigned long lastApiCall = 0; // üî• Needed for fetch timing
unsigned long lastMemoryCheck = 0;
unsigned long lastWeatherUpdate = 0;
unsigned long lastNTPUpdate = 0;

const unsigned long WEATHER_UPDATE_INTERVAL = 30UL * 60UL * 1000UL; // 30 minutes
const unsigned long NTP_UPDATE_INTERVAL = 10UL * 60UL * 1000UL;     // 10 minutes
const unsigned long MEMORY_CHECK_INTERVAL = 5UL * 60UL * 1000UL;    // 5 minutes

const uint32_t BTC_INTERVAL     = 300000;   // 5 min
const uint32_t FEE_INTERVAL     = 300000;   // 5 min
const uint32_t BLOCK_INTERVAL   = 300000;   // 5 min
const uint32_t WEATHER_INTERVAL = 1800000;  // 30 min

const uint32_t FEE_OFFSET     =  90000;   // +1.5 min after BTC
const uint32_t BLOCK_OFFSET   = 180000;   // +3   min after BTC
const uint32_t WEATHER_OFFSET =  60000;   // +1   min after BTC

static uint32_t lastBTC = 0, lastFee = 0, lastBlock = 0, lastWeather = 0;
static uint32_t bootMs = 0;


// Pre Connection Message for home users
void showPreConnectionMessage()
{
  static uint8_t step = 0;
  static unsigned long lastUpdate = 0;

  if (millis() - lastUpdate < 2500)
    return; // Wait for 2.5 seconds between steps
  lastUpdate = millis();

  switch (step)
  {
  case 0:
    P.displayZoneText(ZONE_UPPER, "ENTER THE", PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "MATRIX", PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
    break;
  case 1:
    P.displayZoneText(ZONE_UPPER, "Connect Your", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "Device Inside", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 2:
    P.displayZoneText(ZONE_UPPER, "WiFi Settings", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "Labelled", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 3:
    P.displayZoneText(ZONE_UPPER, "Stacksworth", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "MATRIX", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 4:
    P.displayZoneText(ZONE_UPPER, "OR TYPE", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "192.168.4.1", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  case 5:
    P.displayZoneText(ZONE_UPPER, "SETUP WiFi", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "and hit SAVE", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    break;
  default:
    step = 0; // Reset the sequence
    return;
  }

  step++;
}

 //Load Saved WiFi + City + Timezone on Boot
void loadSavedSettingsAndConnect() {
  prefs.begin("stacksworth", true);  

  savedSSID = prefs.getString("ssid", "");
  savedPassword = prefs.getString("password", "");
  savedCity = prefs.getString("city", "");
  savedTimezone = prefs.getInt("timezone", -99);

  prefs.end();

  if (savedSSID != "" && savedPassword != "") {
    Serial.println("‚úÖ Found Saved WiFi Credentials:");
    Serial.println("SSID: " + savedSSID);
    Serial.println("Password: " + savedPassword);
    Serial.println("City: " + savedCity);
    Serial.print("Timezone offset (hours): ");
    Serial.println(savedTimezone);

    WiFi.mode(WIFI_STA);
    WiFi.begin(savedSSID.c_str(), savedPassword.c_str());

    Serial.print("üîå Connecting to WiFi...");
    unsigned long startAttemptTime = millis();

    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 15000) {
      Serial.print(".");
      delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ Connected to WiFi successfully!");
      Serial.print("üåç IP Address: ");
      Serial.println(WiFi.localIP());
      wifiConnected = true; // üëâ set this!!
      
      if (savedTimezone != -99) {
        gmtOffset_sec = savedTimezone * 3600;
        configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
        Serial.println("üïí Timezone configured");
      }
    } else {
      Serial.println("\n‚ùå Failed to connect to WiFi, falling back to Access Point...");
      startAccessPoint();
    }
  } else {
    Serial.println("‚ö†Ô∏è No saved WiFi credentials found, starting Access Point...");
    startAccessPoint();
  }
}

  
    // Access Point Code
    void startAccessPoint()
    {
      Serial.println("üöÄ Starting Access Point...");
      WiFi.mode(WIFI_AP);
      macID = getShortMAC();  // Store globally
      String ssid = "SW-MATRIX-" + getShortMAC();
      WiFi.softAP(ssid.c_str());


      IPAddress myIP = WiFi.softAPIP();
      Serial.print("üåç AP IP address: ");
      Serial.println(myIP);
      Serial.print("üì∂ AP SSID: ");
      Serial.println(ssid); // Helpful for debug

      // DNS Captive portal
      dnsServer.start(53, "*", myIP);
      Serial.println("üöÄ DNS Server started for captive portal.");
    }

    // FETCH FUNCTIONS
    void fetchBitcoinData() {
  if (ESP.getFreeHeap() < 160000) {
    Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
    return;
  }
  Serial.println("üîÑ Fetching BTC Price...");
  HTTPClient http;
  http.begin(BTC_API);
  if (http.GET() == 200) {
    DynamicJsonDocument doc(512);
    deserializeJson(doc, http.getString());
    btcPrice = doc["bitcoin"]["usd"];
    btcChange24h = doc["bitcoin"]["usd_24h_change"];
    satsPerDollar = 100000000 / btcPrice;

    sprintf(btcText, "$%s", formatWithCommas(btcPrice).c_str());
    sprintf(satsText, "%d sats", satsPerDollar);
    snprintf(changeText, sizeof(changeText), "%+.2f%%", btcChange24h);

    Serial.printf("‚úÖ Updated BTC Price: $%d | Sats per $: %d\n", btcPrice, satsPerDollar);
    Serial.printf("‚úÖ BTC Price: %s (%s)\n", btcText, satsText);
  } else {
    Serial.println("‚ùå Failed to fetch BTC Price");
  }
  http.end();
  Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
}


    void fetchBlockHeight()
    {
      if (ESP.getFreeHeap() < 160000)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      Serial.println("üîÑ Fetching Block Height...");
      HTTPClient http;
      http.begin(BLOCK_API);
      if (http.GET() == 200)
      {
        blockHeight = http.getString().toInt();
        sprintf(blockText, "%d", blockHeight);
        Serial.printf("‚úÖ Updated Block Height: %d\n", blockHeight);
        Serial.printf("‚úÖ Block Height: %s\n", blockText);
      }
      else
      {
        Serial.println("‚ùå Failed to fetch Block Height");
      }
      http.end();
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    void fetchFeeRate() {
  if (heap_caps_get_free_size(MALLOC_CAP_DEFAULT) < 160 * 1024) {
    Serial.println("üõë Low heap before Fee fetch; skipping");
    return;
  }
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üåê WiFi not connected; skipping Fee fetch");
    return;
  }

  Serial.println("üîÑ Fetching Fee Rate‚Ä¶");
  HTTPClient http;
  // short, explicit timeouts so we never stall long enough to trip WDT
  http.setTimeout(3000);         // total I/O timeout ~3s
  http.setConnectTimeout(2000);  // TCP connect timeout ~2s
  http.useHTTP10(true);          // simpler, avoids chunking issues
  http.setReuse(false);          // no keep-alive reuse

  // FEES_API should be your existing endpoint string, unchanged
  if (!http.begin(httpClient, FEES_API)) {
    Serial.println("‚ùå http.begin failed; keeping last fee value");
    return;
  }

  int rc = http.GET();
  if (rc == 200) {
    String payload = http.getString();
    DynamicJsonDocument doc(512);
    DeserializationError e = deserializeJson(doc, payload);
    if (e) {
      Serial.printf("‚ùå Fee JSON parse error: %s; keeping last value\n", e.c_str());
    } else {
      // keep previous value if field missing
      int newFee = doc["fastestFee"] | feeRate;
      feeRate = newFee;
      // feeText should be your existing global char buffer
      snprintf(feeText, sizeof(feeText), "%d sat/vB", feeRate);
      Serial.printf("‚úÖ Updated Fee Rate: %d sat/vB\n", feeRate);
    }
  } else {
    Serial.printf("‚ùå Fee GET failed (%d); keeping last value\n", rc);
  }
  http.end();
}


    void fetchTime()
    {
      if (ESP.getFreeHeap() < 160000)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      struct tm timeinfo;
      if (!getLocalTime(&timeinfo))
      {
        Serial.println("‚ùå Failed to fetch local time! Keeping previous timeText...");
        return; // Don't overwrite global time values if fetch fails
      }

      Serial.println("‚è∞ Local time fetched successfully!");

      // Format to HH:MMam/pm, then strip leading zero
      char buf[16];
      strftime(buf, sizeof(buf), "%I:%M%p", &timeinfo);
      if (buf[0] == '0')
        memmove(buf, buf + 1, strlen(buf + 1) + 1); // Strip leading 0

      // ‚úÖ Update globals only if time fetch succeeded
      strncpy(timeText, buf, sizeof(timeText));
      timeText[sizeof(timeText) - 1] = '\0';

      strftime(dateText, sizeof(dateText), "%b %d", &timeinfo);
      strftime(dayText, sizeof(dayText), "%A", &timeinfo);

      Serial.printf("‚úÖ Updated Time: %s | Date: %s | Day: %s\n", timeText, dateText, dayText);
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    void fetchLatLonFromCity()
    {
      if (ESP.getFreeHeap() < 160000)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      if (savedCity == "")
      {
        Serial.println("‚ö†Ô∏è No saved city found, skipping geolocation fetch.");
        return;
      }

      HTTPClient http;
      String url = "https://nominatim.openstreetmap.org/search?city=" + savedCity + "&format=json";
      http.begin(url);
      int httpResponseCode = http.GET();

      if (httpResponseCode == 200)
      {
        DynamicJsonDocument doc(2048);
        deserializeJson(doc, http.getString());

        if (!doc.isNull() && doc.size() > 0)
        {
          String latStr = doc[0]["lat"];
          String lonStr = doc[0]["lon"];

          Serial.println("üåé Found City Location:");
          Serial.println("Latitude: " + latStr);
          Serial.println("Longitude: " + lonStr);

          latitude = latStr.toFloat();
          longitude = lonStr.toFloat();
        }
        else
        {
          Serial.println("‚ùå No matching city found!");
        }
      }
      else
      {
        Serial.print("‚ùå HTTP Request failed, code: ");
        Serial.println(httpResponseCode);
      }

      http.end();
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    void fetchWeather()
    {
      if (ESP.getFreeHeap() < 160000)
      {
        Serial.println("‚ùå Not enough heap to safely fetch. Skipping BTC fetch.");
        return;
      }
      if (savedCity == "")
      {
        Serial.println("‚ùå City not set, skipping weather fetch.");
        return;
      }

      String weatherURL = "https://api.open-meteo.com/v1/forecast?latitude=" + String(latitude, 6) +
                          "&longitude=" + String(longitude, 6) +
                          "&current=temperature_2m,weather_code&timezone=auto";

      HTTPClient http;
      http.begin(weatherURL);
      int httpCode = http.GET();

      if (httpCode == 200)
      {
        String payload = http.getString();
        if (payload.length() == 0)
        {
          Serial.println("‚ùå Empty weather payload received!");
          http.end();
          return;
        }

        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, payload);

        if (!error)
        {
          float temp = doc["current"]["temperature_2m"];
          int weatherCode = doc["current"]["weather_code"];
          String condition = mapWeatherCode(weatherCode);

          temperature = (int)temp;
          weatherCondition = condition;
          Serial.printf("‚úÖ Updated Weather: %d¬∞C | Condition: %s\n", temperature, weatherCondition.c_str());
          Serial.print("üå°Ô∏è Temperature: ");
          Serial.println(temperature);
          Serial.println("üå¶Ô∏è Condition: " + weatherCondition);
        }
        else
        {
          Serial.println("‚ùå Failed to parse weather JSON");
        }
      }
      else
      {
        Serial.println("‚ùå Weather fetch failed, HTTP code: " + String(httpCode));
      }

      http.end(); // ‚úÖ Always clean up!
      Serial.printf("üìà Free heap after fetch: %d bytes\n", ESP.getFreeHeap());
    }

    // Setup of device

    void setup()
    {
      Serial.begin(115200);
      Serial.println("üöÄ Starting STACKSWORTH Matrix Setup...");


      //Adding MAC Address to ID
      macID = getShortMAC();
      Serial.println("üÜî MAC Fragment: " + macID);

      prefs.begin("device", false);
      prefs.putString("shortMAC", macID);
      prefs.end();

    

      // Monitor available heap memory
      Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
      Serial.printf("Minimum free heap: %d bytes\n", ESP.getMinFreeHeap());
      Serial.printf("Free PSRAM: %d bytes\n", ESP.getFreePsram());

      // üóÇÔ∏è Mount SPIFFS
      Serial.println("üóÇÔ∏è Mounting SPIFFS...");
      if (!SPIFFS.begin(true))
      {
        Serial.println("‚ùå Failed to mount SPIFFS");
        return;
      }
      Serial.println("‚úÖ SPIFFS mounted successfully!");

      if (!SPIFFS.exists("/STACKS_Wifi_Portal.html.gz"))
      {
        Serial.println("‚ùå HTML file NOT found");
      }
      else
      {
        Serial.println("‚úÖ Custom HTML file found");
      }

      // Try WiFi first, fallback if needed
      Serial.println("üì° Loading saved WiFi and settings...");
      loadSavedSettingsAndConnect();

      // LED Matrix Startup
      Serial.println("üí° Initializing LED Matrix...");
      P.begin(MAX_ZONES);
      P.setZone(ZONE_LOWER, 0, ZONE_SIZE - 1);
      P.setZone(ZONE_UPPER, ZONE_SIZE, MAX_DEVICES - 1);
      P.setFont(nullptr);
      // P.setIntensity(brightnessLevel);

      // Show Welcome Loop
      if (!wifiConnected)
      {
        // Show Welcome Loop only if WiFi NOT connected
        unsigned long startTime = millis();
        while (millis() - startTime < 21000)
        {
          showPreConnectionMessage();
          P.displayAnimate();
        }
      }

      // üïí Time Config
      Serial.println("üïí Configuring time...");
      configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

      // Serve Custom HTML File
      server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
                {
  if (SPIFFS.exists("/STACKS_Wifi_Portal.html.gz")) {
    AsyncWebServerResponse *response = request->beginResponse(SPIFFS, "/STACKS_Wifi_Portal.html.gz", "text/html");
    response->addHeader("Content-Encoding", "gzip"); // Inform the browser that the file is GZIP-compressed
    request->send(response);
  } else {
    request->send(404, "text/plain", "Custom HTML file not found");
  } });

      // üìù Handle Save Form Submission
      server.on("/save", HTTP_POST, [](AsyncWebServerRequest *request)
                {
  if (request->hasParam("ssid", true) && request->hasParam("password", true)) {
    String ssid = request->getParam("ssid", true)->value();
    String password = request->getParam("password", true)->value();
    String city = request->getParam("city", true)->value();
    String timezone = request->getParam("timezone", true)->value();

    Serial.println("‚úÖ Saving WiFi Settings:");
    Serial.println("SSID: " + ssid);
    Serial.println("Password: " + password);
    Serial.println("City: " + city);
    Serial.println("Timezone: " + timezone);

    prefs.begin("stacksworth", false);
    prefs.putString("ssid", ssid);
    prefs.putString("password", password);
    prefs.putString("city", city);
    prefs.putInt("timezone", timezone.toInt());
    prefs.end();
    Serial.println("‚úÖ Settings saved to NVS!");


    // ‚úÖ SEND HTTP 200 RESPONSE FIRST
    request->send(200, "text/plain", "Settings saved! Rebooting...");

    delay(2000); // small delay to let browser receive the message
        // Matrix Feedback
    P.displayZoneText(ZONE_UPPER, "SETTINGS", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "SAVED", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    delay(2500);

    P.displayZoneText(ZONE_UPPER, "REBOOTING", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    P.displayZoneText(ZONE_LOWER, "...", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
    delay(2000);

    ESP.restart();
  } else {
    Serial.println("‚ùå Missing parameters in form submission!");
    request->send(400, "text/plain", "Missing parameters");
  } });


      // Serve MAC fragment to the portal
      server.on("/macid", HTTP_GET, [](AsyncWebServerRequest *request) {
      request->send(200, "text/plain", getShortMAC());
    });


      // Captive Portal Redirect
      server.onNotFound([](AsyncWebServerRequest *request)
                        { request->redirect("/");
                        });

      // Start Web Server
      Serial.println("üåê Starting Async Web Server...");
      delay(2000); // üïí Let WiFi fully stabilize first
      server.begin();
      Serial.println("üåç Async Web server started");
      delay(2000); // üïí Let server stabilize after starting

      bootMs = millis();

      // Initial API Fetch
      Serial.println("üåç Fetching initial data...");
      fetchBitcoinData();
      fetchBlockHeight();
      fetchFeeRate();
      fetchTime();
      fetchLatLonFromCity();
      fetchWeather();
      lastFetchTime = millis();
      Serial.println("‚úÖ Initial data fetch complete!");

      lastWeatherUpdate = millis() - WEATHER_UPDATE_INTERVAL; // ‚¨ÖÔ∏è force weather update ready immediately

      

      // Show Connection Success Message
      Serial.println("üì¢ Displaying WiFi connected message on Matrix...");
      P.displayZoneText(ZONE_UPPER, "WIFI", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
      P.displayZoneText(ZONE_LOWER, "CONNECTED", PA_CENTER, 0, 2000, PA_FADE, PA_FADE);
      delay(2000);
      

      // üëá  Manually trigger first animation cycle!
      cycle = 0;                                              // Start at first data set
      lastApiCall = millis() - FETCH_INTERVAL;                // Force immediate fetch
      lastWeatherUpdate = millis() - WEATHER_UPDATE_INTERVAL; // Force weather update soon
      lastNTPUpdate = millis() - NTP_UPDATE_INTERVAL;         // Force NTP update soon

     pinMode(BUTTON_PIN, INPUT_PULLUP);  //added this for the Smash Buy Button!!!

      esp_task_wdt_config_t wdt_config = {
          .timeout_ms = 12000,                             // 12 seconds
          .idle_core_mask = (1 << portNUM_PROCESSORS) - 1, // All cores
          .trigger_panic = true                            // Reset if not fed in time
      };
      esp_task_wdt_init(&wdt_config);

      esp_task_wdt_add(NULL); // Add current task to WDT
    }

    

    
    void loop()
    {
      esp_task_wdt_reset();           // Reset watchdog
      dnsServer.processNextRequest(); // Handle captive portal DNS magic


// üõ†Ô∏è Smash Buy Button Polling (Debounced)
static bool lastButtonState = HIGH;
bool currentButtonState = digitalRead(BUTTON_PIN);

if (lastButtonState == HIGH && currentButtonState == LOW) {
  // Falling edge: button was released, now pressed
  Serial.println("üö® SMASH BUY Button Pressed!");
  buttonPressed = true;
}

lastButtonState = currentButtonState;

// USED FOR RANDOM PHRASES
if (buttonPressed) {
  buttonPressed = false;  // consume the event so it fires once

int idx = random(NUM_PHRASES);
const char* topLine    = PHRASES[idx][0];
const char* bottomLine = PHRASES[idx][1];

// Optional: small press lockout to avoid double-fires on long press/bounce
static unsigned long pressLockUntil = 0;
if (millis() < pressLockUntil) return;
pressLockUntil = millis() + 600; // 0.6s cooldown

// Show the message (nice and clean fade). Use your zone IDs as you already do.
// If you prefer, you can show the same phrase on both lines for impact.
P.displayClear();
P.displayZoneText(1, topLine,    PA_CENTER, 0, 2500, PA_FADE, PA_FADE);
P.displayZoneText(0, bottomLine, PA_CENTER, 0, 2500, PA_FADE, PA_FADE);

// Let the animation finish while keeping WDT happy (ESP32)
while (!P.displayAnimate()) {
  esp_task_wdt_reset();
  delay(10);
}

P.displayClear();
P.synchZoneStart();
Serial.print("üéØ Smash Buy: ");
Serial.print(topLine);
Serial.print(" / ");
Serial.println(bottomLine);

}




  unsigned long currentMillis = millis();
      

      // ‚úÖ Monitor heap health every 60 seconds
      static unsigned long lastMemoryCheck = 0;
      if (currentMillis - lastMemoryCheck >= 60000)
      {
        Serial.printf("üß† Free heap: %d | Min ever: %d\n", ESP.getFreeHeap(), ESP.getMinFreeHeap());
        lastMemoryCheck = currentMillis;
      }

      // üö® Auto-reboot if heap drops too low
      if (ESP.getFreeHeap() < 140000)
      {
        Serial.println("üö® CRITICAL: Free heap dangerously low. Rebooting to recover...");
        delay(1000); // Give time for message to print
        ESP.restart();
      }

      // ‚è∞ Fetch Time every 1 minute
      static unsigned long lastTimeFetch = 0;
      if (currentMillis - lastTimeFetch >= 60000)
      {
        fetchTime();
        lastTimeFetch = currentMillis;
      }

      // ‚îÄ‚îÄ HTTP scheduler: serialize network calls to avoid overlap
if (WiFi.status() == WL_CONNECTED) {
  uint32_t now = millis();

  // 1) BTC every BTC_INTERVAL
  if (now - lastBTC >= BTC_INTERVAL) {
    fetchBitcoinData();
    lastBTC = now;
  }
  // 2) Fee at +offset
  else if ((now - lastFee >= (FEE_INTERVAL + FEE_OFFSET)) && (now >= bootMs + FEE_OFFSET)) {
    fetchFeeRate();
    lastFee = now;
  }
  // 3) Block height at +offset
  else if ((now - lastBlock >= (BLOCK_INTERVAL + BLOCK_OFFSET)) && (now >= bootMs + BLOCK_OFFSET)) {
    fetchBlockHeight();
    lastBlock = now;
  }
  // 4) Weather seldom, with a small offset
  else if ((now - lastWeather >= (WEATHER_INTERVAL + WEATHER_OFFSET)) && (now >= bootMs + WEATHER_OFFSET)) {
    fetchWeather();
    lastWeather = now;
  }
}

      
/*
      // üå¶Ô∏è Fetch Weather every 30 minutes
      static unsigned long lastWeatherFetch = 0;
      if (currentMillis - lastWeatherFetch >= 1800000)
      {
        fetchWeather();
        lastWeatherFetch = currentMillis;
      }

      // üîÑ Fetch BTC Price and Fee Rate every 5 minutes
      static unsigned long lastBTCFeeFetch = 0;
      if (currentMillis - lastBTCFeeFetch >= 300000)
      {
        fetchBitcoinData();
        fetchFeeRate();
        lastBTCFeeFetch = currentMillis;
      }

      // üîÑ Fetch Block Height every 5 minutes (offset by 2.5 minutes)
      static unsigned long lastBlockHeightFetch = 0;
      if (currentMillis - lastBlockHeightFetch >= 300000)
      {
        fetchBlockHeight();
        lastBlockHeightFetch = currentMillis;
      }

*/


      // üñ•Ô∏è Rotate screens
  if (P.displayAnimate()) {
    Serial.print("üñ•Ô∏è Displaying screen: ");
    Serial.println(displayCycle);

    switch (displayCycle) {
      case 0:
        Serial.println("üñ•Ô∏è Displaying BLOCK screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "BLOCK", blockText); 
        P.displayZoneText(ZONE_UPPER, "BLOCK", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, blockText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;

     case 1:
        Serial.println("üñ•Ô∏è Displaying USD PRICE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "USD PRICE", btcText);
        P.displayZoneText(ZONE_UPPER, "USD PRICE", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, btcText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;   
     case 2:
        Serial.println("üñ•Ô∏è Displaying 24H CHANGE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "24H CHANGE", changeText);
        P.displayZoneText(ZONE_UPPER, "24H CHANGE", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, changeText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear();
        P.synchZoneStart();
        break;

      case 3:
        Serial.println("üñ•Ô∏è Displaying SATS/$ screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "MOSCOW TIME", satsText);
        P.displayZoneText(ZONE_UPPER, "SATS/USD", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, satsText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization  
        break;

      case 4:
        Serial.println("üñ•Ô∏è Displaying MOSCOW TIME screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "MOSCOW TIME", satsText);
        P.displayZoneText(ZONE_UPPER, "MOSCOW TIME", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, satsText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization  
        break;
        
      case 5:
        Serial.println("üñ•Ô∏è Displaying FEE RATE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "FEE RATE", feeText);
        P.displayZoneText(ZONE_UPPER, "FEE RATE", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, feeText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      case 6:
        Serial.println("üñ•Ô∏è Displaying TIME screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", "TIME", timeText);
        P.displayZoneText(ZONE_UPPER, savedCity.c_str(), PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, timeText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      case 7:
        Serial.println("üñ•Ô∏è Displaying DAY/DATE screen...");
        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", dayText, dateText);
        P.displayZoneText(ZONE_UPPER, dayText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, dateText, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      case 8: {
        Serial.println("üñ•Ô∏è Displaying WEATHER screen...");
        static char tempDisplay[16];
        snprintf(tempDisplay, sizeof(tempDisplay), (temperature >= 0) ? "+%dC" : "%dC", temperature);
        String cond = weatherCondition;
        cond.replace("_", " ");
        cond.toLowerCase();
        cond[0] = toupper(cond[0]);
        static char condDisplay[32];
        strncpy(condDisplay, cond.c_str(), sizeof(condDisplay));
        condDisplay[sizeof(condDisplay) - 1] = '\0';

        Serial.printf("üî§ Displaying text: %s (Top), %s (Bottom)\n", tempDisplay, condDisplay);
        P.displayZoneText(ZONE_UPPER, tempDisplay, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayZoneText(ZONE_LOWER, condDisplay, PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
        P.displayClear(); //  Force clear
        P.synchZoneStart(); // Force synchronization
        break;
      }

      case 9:// This is for the models we ship but can be changed for custom units
        P.displayZoneText(ZONE_UPPER, "CRYPTO", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT); 
        P.displayZoneText(ZONE_LOWER, "CLOAKS", PA_CENTER, SCROLL_SPEED, 10000, PA_SCROLL_LEFT, PA_SCROLL_LEFT); 
        P.displayClear();
        P.synchZoneStart();
        break;
    }

      Serial.println("‚úÖ Screen update complete.");
      displayCycle = (displayCycle + 1) % 10;
      P.displayClear();
      P.synchZoneStart();
    }
  }
